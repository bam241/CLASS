%\RequirePackage{lineno}
\documentclass[12pt,a4paper,twoside,titlepage,final,openany]{book}


%% ---- style files ------
\usepackage{bstyle}

%\author{B. MOUGINOT \& B. LENIAU}
%\title{CLASS Userguide.}
%
%\date\today



%----------------------------------------------------------------------------------------
%	BLANK DOCUMENT
%----------------------------------------------------------------------------------------


%% --------- MAIN -------------
\begin{document}
\titleGM % This command includes the title page
% === title and abst. ===
\pagestyle{empty}
%\include{abstract}
\frontmatter
\phantomsection
\addcontentsline{toc}{part}{Abstract}
\chapter*{{\large Abstract}}
\clearpage
\phantomsection
\addcontentsline{toc}{part}{Table of Contents}
\tableofcontents
%
\clearpage
\phantomsection
\addcontentsline{toc}{part}{List of figures}
\listoffigures


%%%%%%%%%%%%%%%%%%%%%%%%%
%% CHAPTER :	INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\part{Introduction}
code de scenar tatati c'est gnial ça sert à ça ça et ça ...
donner le forge in2p3

\part{First Steps}
\chapter{Package Contents}
Ya quoi dans ce que je viens de downloader
\chapter{Install procedure}

\section{Requirement}

\begin{center}
\begin{minipage}{\textwidth}
\begin{itemize}
\item User skills : Good knowledge of C++. Abilities in using Root (cern). Experience in depletion codes and neutron transport codes.
\item OS : CLASS is known to work under Linux (64  bits) and MacOSX (64 bits). It  has never been tested on any Windows distribution.
\item Root (CERN) :  
CLASS uses Root to store output data. 
The graphical user interface CLASSGui is based on Root.
Some algorithms uses the TMVA module of Root.
 \item C++ compiler :  we recommend to use a gnu compiler like gcc4.8. 
If your platform is DARWIN (Mackintosh OSX) we strongly recommend not to use the clang compiler\\
You should install macport. then types this following command in terminal :\\
\begin{lstlisting}[style=terminal]
sudo port install gcc48
sudo port select --set gcc mp-gcc48
\end{lstlisting}
\end{itemize}
\end{minipage}
\end{center}

\begin{center}
\line(1,0){250}
\end{center}

\begin{large}
\begin{center}
\textbf{IMPORTANT NOTE : } \\
\end{center}

\end{large} 
The actual root package (version 5.34/20 ) and earlier (and maybe latter) has a memory leak issue when using TMVA leading to a \textbf{freeze of your computer.}
To avoid this dramatical error to happen do the following : \\
If the thread 
\href{http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18360&p=78586&hilit=TMVA#p78586}{RootTalk}
\footnote{http://root.cern.ch/phpBB3/viewtopic.php?f=3\&t=18360\&p=78586\&hilit=TMVA\#p78586} 
or \href{https://sft.its.cern.ch/jira/browse/ROOT-6551}{RootSupport} \footnote{https://sft.its.cern.ch/jira/browse/ROOT-6551}
indicates status solved then download and install  the more recent ROOT version.\\
If the status is still unresolved proceed as follow : \\
Open with your favourite text editor the file  \$ROOTSYS/tmva/src/Reader.cxx (\$ROOTSYS is the path to your ROOT installation folder) and replace the following :\\

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
TMVA::Reader::~Reader( void )
{
   // destructor

   delete fDataSetManager; // DSMTEST

   delete fLogger;
}
\end{lstlisting}
\end{minipage}
\end{center}

by :\\
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
TMVA::Reader::~Reader( void )
{
   // destructor
   std::map<TString, IMethod* >::iterator itr;
   for( itr = fMethodMap.begin(); itr != fMethodMap.end(); itr++) {
      delete itr->second;
   }
   fMethodMap.clear();

   delete fDataSetManager; // DSMTEST

   delete fLogger;
}
\end{lstlisting}
\end{minipage}
\end{center}

then type in your terminal : 

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $ROOTSYS
sudo make -j
\end{lstlisting}
\end{minipage}
\end{center}

\begin{center}
\line(1,0){250}
\end{center}


\section{Installation}
Decompress the CLASS.tar.gz in your wanted location \footnote{ \$CLASS\_PATH is the path of your CLASS installation folder}. Then type in terminal:\\

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/
mkdir lib
cd  source/src
make -j 
make install
\end{lstlisting}
\end{minipage}
\end{center}

Then to install the Graphical User Interface :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/gui
mkdir bin
make -j
\end{lstlisting}
\end{minipage}
\end{center}

Finally add the following environment variables  (in your .tcsh or .csh ):

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
setenv CLASS_PATH YourPathToCLASS
setenv CLASS_lib ${CLASS_PATH}/lib
setenv CLASS_include ${CLASS_PATH}/source/include
setenv PATH ${PATH}:${CLASS_PATH}/bin/gui
\end{lstlisting}
\end{minipage}
\end{center}

\chapter{CLASS Execution}
CLASS is a set of C++ libraries, there is no CLASS binary file. A CLASS executable has to be build by user using objects and methods defined in the CLASS package. \\
The compilation line for generating your executable from a .cxx file is the following :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
g++ -o CLASS_exec YourScenario.cxx -I $CLASS_include -L $CLASS_lib -lCLASSpkg `root-config --cflags` `root-config --libs` -fopenmp -lgomp -Wunused-result
\end{lstlisting}
\end{minipage}
\end{center}

\chapter{News, forum, troubleshooting, doxygen ...}
CLASS has a \href{https://forge.in2p3.fr/projects/classforge}{forge}\footnote{https://forge.in2p3.fr/projects/classforge} hosted by the IN2P3  where you can find :

\begin{itemize}
\item \href{https://forge.in2p3.fr/projects/classforge/boards}{A forum}\footnote{https://forge.in2p3.fr/projects/classforge/boards} where you are invited to post your trouble about CLASS installation and usage. You may find the answer to your trouble on a already posted thread.
\item \href{https://forge.in2p3.fr/projects/classforge/embedded/annotated.html}{A doxygen}\footnote{https://forge.in2p3.fr/projects/classforge/embedded/annotated.html} where all the CLASS objects and methods are defined and explained.
\item \href{https://forge.in2p3.fr/projects/classforge/news}{News}\footnote{https://forge.in2p3.fr/projects/classforge/news} : All the news related to CLASS
\end{itemize}
A \href{classuser-l@ccpntc02.in2p3.fr}{Mailing List}\footnote{classuser-l@ccpntc02.in2p3.fr} also exist in order to be warned of all the change inside CLASS and to allow user to exchange directly on the code. One can join the mailing list through the following  \href{http://listserv.in2p3.fr/cgi-bin/wa?SUBED1=classuser-l&A=1}{link}\footnote{http://listserv.in2p3.fr/cgi-bin/wa?SUBED1=classuser-l\&A=1}.

%%%%%%%%%%%%%%%%%%%%%%%%%
%% CHAPTER :	GENERAL OVERVIEW
%%%%%%%%%%%%%%%%%%%%%%%%%
\part{CLASS : General overview}
\chapter{Generalities}
\section{Basic unit\label{sec:unit}}
All time in CLASS should be written in second. It corresponds to the cSecond, a CLASS c++ type, which are a \textbf{long long int} going, in 32 bits \textbf{and} 64 bits, up to  $(2^{63} - 1)~\textrm{s}~ \sim 2.9\cdot 10^{11}$ years, enough for any electro-nuclear scenarios one can consider....\\
 \section{CLASS working process principle}
image : shéma de principe de class
\chapter{Facilities descriptions}
All the facility in CLASS project are regroup inside a large group called CLASSFacility (and inherit of all the properties of the CLASSFacility in a C++ way). Inside the CLASSFacility, 3 different types has be defined, the reactor, the FabricationPlant (or more generally, all the fuel cycle front-end facilities) and the backend facilities. 
\section{CLASSFacility\label{sec:CLASSFacility}}
The CLASSFacility should never be used directly in the main CLASS program (the one made to perform the simulation).  The aim of these object is to regroup all the common properties of the nuclear facilities, such as common variables, methods, and builder. 
Its includes 3 variables needed by CLASS environment:
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
private :
	int		fId;						//!< Identity of the Facility inside the Parc
	int		fFacilityType;	///< Type of facility :
												/// \li 4 reactor,
												/// \li 8 Pool,
												/// \li 16 FabricationPlant.
	Scenario*		fParc;		//!< Pointer to the main Parc
\end{lstlisting}
\end{minipage}
\end{center}
The \textit{fId} variable correspond to the unique identity number allowing to differentiate all the facility of a certain type. The \textit{fFacilityType} variable correspond to an identity number allowing to separate the different type of facilities. Those to variable are "\textbf{private}", which mean it is not possible to access to them directly, one \textbf{must} to use there Get-xxx() and the Set-xxx() function (even inside the daughter class such as reactor...). \textit{fParc} is a pointer to the main park, which allow to access to the rest of the park. Be careful the \textit{fParc} pointer main not be assigned if the facility is not included in a park...\\
\\
\\
\\
The CLASSFacility also includes all the generic variable and method for time and simple fuel management:
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
protected :
	bool		fIsStarted;			///< True if Running, False Otherwise
	bool		fIsShutDown;		///< True if the facility is stoped, False Otherwise
	bool		fIsShutDown;	///< True if Reaching the End of a Facility Cycle

		
	cSecond		fInternalTime;		///< Internal Clock
	cSecond		fInCycleTime;			///< Time spend since the beginning of the last Cycle
	cSecond		fCycleTime;				///< Cycle duration Time

	IsotopicVector	fInsideIV;	///< All IV in the Facility (fuel for reactor, total for all others...)
	IsotopicVector	fCumulativeIVIn;	///< All IV in the Facility (fuel for reactor, total for all others...)
	IsotopicVector	fCumulativeIVOut;	///< All IV in the Facility (fuel for reactor, total for all others...)

		//********* Internal Parameter *********//
private :
	[...]
	cSecond		fCreationTime;		///< CLASS Universal Time of Creation
	cSecond		fLifeTime;				///< Time of life Of the Reactor (Operating's Duration)

\end{lstlisting}
\end{minipage}
\end{center}
\textit{fIsStarted}, \textit{fIsShutDown}, \textit{fIsShutDown} allows to the Dump() method to determine the state of the facility and do what is necessary.\\
\textit{fInternalTime}, \textit{fInCycleTime}, \textit{fCycleTime} variable allows the \hyperref[sec:unit]{time} the time management inside the facility. \textit{fInternalTime} correspond to the last time until the evolution of the facility as been calculated. \textit{fCycleTime} the time length of a cycle in this facility (note that it could be irradiation cycle in a \hyperref[sec:reactor]{Reactor}, fabrication time in a \hyperref[sec:FP]{FabricationPlant}, or cooling time in a \hyperref[sec:pool]{Pool}). And \textit{fInCycleTime} correspond to the time already past in the current cycle.\\
\textit{fCreationTime}, \textit{fLifeTime} are \textbf{private} and used to define the creation time of the facility, and its operation time length.
 
Besides all the time management of the facility, it also contain the basic tool for fuel management the three \hyperref[sec:IV]{IsotopicVector} : \textit{fInsideIV}, \textit{fCumulativeIVIn}, \textit{fCumulativeIVOut}, which correspond respectively to the isotopic vector present in the facility, to the cumulative income inside the facility, and the cumulative outcome outside the facility.

By default af the Get-xxx() and Set-xxx() method associated to those variable are define, and some can be overloaded.

The CLASSFacility also comes with 2 virtual method (which means one must  overloading it when defining a new facility) : \textit{Evolution(cSecond t)} and \textit{Dump()}. They are both used to perform the evolution of the facility. Where the first one (\textit{Evolution}) is used to specify the change inside the facility (mainly fuel evolution), the second one (\textit{Dump}) is used to deal the exchange between facility, such as refilling a reactor or send a fuel to the stock at the end of cooling.

\section{Reactor\label{sec:reactor}}
\subsection{Generalities}
 The aim of this class is to deal the evolution of the fuel inside a reactor.
 The fuel state of the reactor is describe in the IsotopicVector fInsideIV (which are inherit from the  \hyperref[sec:CLASSFacility]{CLASSFacility} class). Its evolution is \textbf{always} contain in the \hyperref[sec:EvolutionData]{EvolutionData} \textit{fEvolutionDB}.\\
  There are 2 way to provide the \hyperref[sec:EvolutionData]{EvolutionData} to the reactor. In the case of fixed fuel the user need to provide it, using the appropriated constructor, the set function, or a \hyperref[sec:CLASSFuelPlan]{CLASSFuelPlan}. In the case of recycled fuel or unfixed fuel, the user need to provide a \hyperref[sec:PhysicsModels]{PhysicsModels}, using the appropriated constructor, the set function, and/or a \hyperref[sec:CLASSFuelPlan]{CLASSFuelPlan}.

\subsection{Constructor\label{sec:reactor:constructor}}
There are many ways to define a reactor.
\subsubsection{Normal constructor}
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
	Reactor();		///< Normal Constructor.
\end{lstlisting}
\end{minipage}
\end{center}
Just define a simple reactor without fuel, starting time,  mass of fuel, time of life or anything.
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
	Reactor(CLASSLogger* log);
\end{lstlisting}
\end{minipage}
\end{center}
Just define a simple reactor without fuel, starting time,  mass of fuel, time of life or anything, but set a \hyperref[sec:CLASSLogger]{CLASSLogger} \textit{log} to send the CLASS message.
\vspace{3cm}

\subsubsection{Fixed fuel constructor}
Constructor defining a reactor using fixed fuel. 
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
	Reactor(CLASSLogger* log, EvolutionData evolutivedb, CLASSBackEnd* CBE,
		cSecond creationtime, cSecond lifetime,
		double power, double HMMass, double BurnUp, double CapacityFactor = 1);
\end{lstlisting}
\begin{lstlisting}
	Reactor(CLASSLogger* log, EvolutionData evolutivedb, CLASSBackEnd* Pool,
		cSecond creationtime, cSecond lifetime,
		cSecond cycletime, double HMMass, double BurnUp);
\end{lstlisting}
\end{minipage}
\end{center}
The evolution of the fuel is given by the \hyperref[sec:EvolutionData]{EvolutionData} \textit{evolutivedb} the mass of heavy metal in the reactor core by \textit{HMMass}, the power by \textit{Power} and  its capacity factor by \textit{CapacityFactor}.\\
To avoid mixing between constructor, only 2 constructors exist to set the triplet (power, burnup, cycle time). (if more 2 constructor would have the same number of input variables.)\\
After irradiation the fuel goes in the \hyperref[sec:CLASSBackEnd]{CLASSBackEnd} CBE, which as seen section \label{sec:CLASSBackEnd} can be any CLASSBackEndFacility (SeparationPlant, Pool or storage).

\subsubsection{Reprocessed fuel constructor}
As well as in the fixed fuel constructor, the mass of heavy metal in the reactor core by \textit{HMMass}, the power by \textit{Power} and  its capacity factor by \textit{CapacityFactor}. Only 2 constructors exist to set the triplet (power, burnup, cycle time).\\
The \hyperref[sec:PhysicsModels]{PhysicsModels} is \textit{fuelDB}, and the \hyperref[sec:FabricationPlant]{FabricationPlant} is \textit{FabricationPlant}.
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
	Reactor(CLASSLogger* log, PhysicsModels 	fueltypeDB,
		FabricationPlant* fabricationplant, CLASSBackEnd* Pool,
		cSecond creationtime , cSecond lifetime, cSecond cycletime,
		double HMMass, double BurnUp);
\end{lstlisting}
\begin{lstlisting}
	Reactor(CLASSLogger* log, PhysicsModels 	fueltypeDB,
		FabricationPlant* fabricationplant, CLASSBackEnd* Pool,
		cSecond creationtime , cSecond lifetime,
		double Power, double HMMass, double BurnUp, double CapacityFactor);
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Main methods}
Despite all the Get-xxx() and Set-xxx() method, Reactor possess 3 main method, Evolution(), Dump() and SetStorage() (yes this is a Set-xxx() method...).
\subsubsection{Evolution}
The evolution function is quite simple, it only follow the \hyperref[sec:EvolutionData]{EvolutionData}, containing all the information about the fuel evolution.
When called the \textit{Evolution(cSecond t)} method, the reactor will perform its evolution until the time \textit{t}.\\\\
\fbox{
\begin{minipage}{\textwidth}
\textbf{Note that, the reactor \textcolor{red}{MUST} have a time step at the exact second of its end of cycle, start or shutdown, if not the CLASS will break returning : }\\
"Evolution is too long! There is a problem in Reactor evolution at ..."\\
\textbf{as an error, giving also some time information about the break.}
\end{minipage}
}\\\\
Beside the verification if the reactor is started, and its start, the evolution can encounter 2 cases : if the evolution stop during and cycle to at the end of a cycle.
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
if( EvolutionTime + fInCycleTime == fCycleTime )		//End of Cycle
{
	fIsAtEndOfCycle = true;
	fInternalTime += EvolutionTime; 				// Update Internal Time
	fInCycleTime += EvolutionTime;					// Update InCycleTime
	if(t >= GetCreationTime() + GetLifeTime()) // if the Next Cycle don't exist
		fIsShutDown = true;
}
else if(EvolutionTime + fInCycleTime < fCycleTime )			// During Cycle
{
	fInternalTime += EvolutionTime;					// Update Internal Time
	fInCycleTime += EvolutionTime;					// Update InCycleTime

	fInsideIV = fEvolutionDB.GetIsotopicVectorAt( (cSecond)(fInCycleTime/fEvolutionDB.GetPower()*fPower) );	// update the fuel composition
	if(t>=GetCreationTime() + GetLifeTime())	fIsShutDown = true;
}
else
{
	// Evolution goes after the end of cycle.... check it
	exit(1);
}
\end{lstlisting}
\end{minipage}
\end{center}
In the first case, the reactor will only update its \textit{fInsideIV} to the corresponding state.
In the second case, only flag the end of cycle, the rest of the job is don in the \textit{Dump()} method.\\
\\
\\

\subsubsection{Dump}
This method deal all the exchange with the other facility of the scenario. It is divided in two part. The first one trash the used fuel, detecting which case it is (normal end of a cycle, end of cycle ad reactor shutdown, or shutdown during a cycle).
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
if(fIsAtEndOfCycle  && !fIsShutDown )
{
	if(fIsStarted  )					// A Cycle has already been done
	{
		fOutBackEndFacility->AddIV(fInsideIV);
		AddCumulativeIVOut(fInsideIV);
	}
	else fIsStarted = true;					// Just start the first cycle

}
else if (fIsAtEndOfCycle  && fIsShutDown )			//shutdown at end of Cycle
{

	fOutBackEndFacility->AddIV(fIVOutCycle);
	AddCumulativeIVOut(fIVOutCycle);
	fInsideIV.Clear();
	fInCycleTime = 0;
	fIsStarted = false;					// shut down the Reactor
}
else if (!fIsAtEndOfCycle && fIsShutDown ) 			//shutdown during Cycle
{
	fOutBackEndFacility->AddIV(fInsideIV);
	AddCumulativeIVOut(fInsideIV);
	fInsideIV.Clear();
	fInCycleTime = 0;
	fIsStarted = false;					// shut down the Reactor
}

\end{lstlisting}
\end{minipage}
\end{center}

The second part correspond to refilling of the reactor...
For the fixed fuel :
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
fIsAtEndOfCycle = false;
GetParc()->AddGod(fIVInCycle);
fInsideIV  = fIVBeginCycle;
AddCumulativeIVIn(fIVBeginCycle);
fInCycleTime = 0;
\end{lstlisting}
\end{minipage}
\end{center}
where the fuel material is taken outside of the scenario.\\
\\
\begin{center}
\begin{minipage}{\textwidth}
Or for the reprocessed fuel :
\begin{lstlisting}
fIsAtEndOfCycle = false;
SetNewFuel(fFabricationPlant->GetReactorEvolutionDB(GetId()));
fFabricationPlant->TakeReactorFuel(GetId());
fInsideIV  = fIVBeginCycle;
AddCumulativeIVIn(fIVBeginCycle);
fInCycleTime = 0;
\end{lstlisting}
\end{minipage}
\end{center}
where the fuel and the corresponding EvolutionData is builded by a FabricationPlant using the PhysicsModel.

\subsubsection{SetStorage}
The SetStorage() method must be use with caution !! Because its use will modify the normal operation of the reactor.
It can be used only in the case of a fixed fuel reactor and not stock management (all stock ar mixed inside the storage), when one want to take the material inside the stock instead of outside of the scenario. In this case, an isotopic separation of the provided stock is done, the needed isotope are taken from the stock, the missing part is provided by the OutSide of the scenario. The refilling part of the Dump() method becomes :
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
fIsAtEndOfCycle = false;
IsotopicVector BuildIVtmp ;
IsotopicVector GodPart;
//Get The Storage Compostion
BuildIVtmp.Add(fStorage->GetInsideIV().GetIsotopicQuantity());
//Get the rest after IVIn creation
BuildIVtmp -= fIVInCycle;
//Get the God part form this rest
GodPart.Add(BuildIVtmp.GetIsotopicQuantityNeeded()) ;
//Take what you can from Storage...
fStorage->TakeFromStock( fIVInCycle - GodPart);
//And Get the rest from God
GetParc()->AddGod(GodPart);
fInsideIV  = fIVBeginCycle;
AddCumulativeIVIn(fIVBeginCycle);
fInCycleTime = 0;
\end{lstlisting}
\end{minipage}
\end{center}
Again this method is really tricky to use and need to be used with great caution!!!

\subsection{CLASSFuelPlan}
If you don't want to change the fuel type (from a fixed fuel to an other, a fixed fuel to a reprocessed one, changing the final burnup of a fuel...) inside a reactor during its operation stay away from this part.\\
The aim of this class is to allow user to change the fuel parameter during the operation of the reactor, by example setting a reactor with a UOX fuel enriched at 3\% for 3 cycles, then changing to 5\% UOX or even to MOX. All fuel in a CLASSFUelPLan are associated to a burnup. The reactor updating his cycle time to this burnup( considering the power remain the same in a reactor during all its life.\\
The usage of the CLASSFuelPlan is quiet simple... On just need to add to an existing CLASSFuelPlan, a time (to perform the fuel switch), a fuel and an associated burnup. One should note that the fuel in the reactor only change at the end of a cycle (finish the current cycle even after a date to change fuel type.)\\
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
void AddFuel(cSecond time,  EvolutionData* fuel, double BurnUp)
void AddFuel(cSecond time,  PhysicsModels* fuel, double BurnUp)
\end{lstlisting}
\end{minipage}
\end{center}

For the one who want to go further, when declaring a reactor (using any type of fuel) (see \ref{sec:reactor:constructor}), a CLASSFuelPlan is created inside the reactor. So it is possible to create a reactor using the normal reactor creator (which include a fuel...) and add after some fuel to the plan using \textit{
CLASSFuelPlan*	GetFuelPlan()} method of the reactor, then the AddFuel method of CLASSFuelPlan.\\
ie : 
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
CLASSLogger *MyLogger = new CLASSLogger("CLASS_OUTPUT.log",1,2);
EvolutionData* STD900 = new EvolutionData(MyLogger, "STD900.dat",false);
EvolutionData* GARANCE = new EvolutionData(MyLogger, "GARANCE.dat",false);
Reactor* MyReactor = new Reactor(MyLogger, STD900, Cooling_UOX, 0., 40*3600*24*365.25, 900e6, 106, 33, 0.8);
Myreactor->GetFuelPlan()->AddFuel(2001*3600*24*365.25, GRANACE, 42);
\end{lstlisting}
\end{minipage}
\end{center}
If one want to switch between fixed fuel (e.g. PWR UOX) to recycled fuel (e.q. PWR MOX) one need to define a FabricationPlant to the reactor :
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
IM_RK4 *IMRK4 = new IM_RK4(MyLogger);
EQM_LIN_PWR_MOX* EQMLINPWRMOX = new EQM_LIN_PWR_MOX(MyLogger, "EQ_Lin.dat");
EQM_QUAD_PWR_MOX* EQMQUADPWRMOX = new EQM_QUAD_PWR_MOX(MyLogger, "DB.dat");
PhysicsModels* PHYMOD = new PhysicsModels(XSMOX, EQMQUADPWRMOX, IMRK4);
Myreactor->GetFuelPlan()->AddFuel( MOXTime, PHYMOD, 35);
Myreactor->SetFabricationPlant(FP_MOX);

\end{lstlisting}
\end{minipage}
\end{center}




\section{CLASSBackEnd}
\subsection{Storage}
\subsection{Pool\label{sec:pool}}
\section{Fabrication Plant\label{sec:FP}}

\chapter{Other objects}
\section{ZAI}
\section{IsotopicVector\label{sec:IV}}
\section{Log management : CLASSLogger}\label{sec:logclass}
\section{EvolutionData}\label{sec:EvolutionData}
\chapter{Decay data bases}\label{sec:DecayDB}


%%%%%%%%%%%%%%%%%%%%%%%%%
%% CHAPTER :		Physics MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Physics Models\label{sec:PhysicsModels}}
\chapter{Description and implementation}
A Physics Models is related to one or several reactors , it is a container of three models :
\begin{itemize}
\item Equivalence Model : Tells to the Fabrication Plant how to build the fuel.
\item XS Model : "Calculates" the mean  cross sections of this fuel and sends it to the Bateman Solver.
\item Irradiation Model : It is the Bateman Solver. User can choose between different numerical method.
\end{itemize}

A Physics model is called in the CLASS input like the following example :

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx :}
\begin{lstlisting}[label=lst:PIMP_HYMOD, caption=PhysicsModels]
...
#include "XS/XSM_MLP.hxx"
#include "Irradiation/IM_RK4.hxx"
#include "Equivalence/EQM_MLP_PWR_MOX.hxx"
int main()
{
	....

	EQM_MLP_MOX* Equivalence 	= new EQM_MLP_MOX( "PathToTMVAWeightFile/TMVAWeightFile.xml" );
	XSM_MLP* XS = new XSM_MLP( gCLASS->GetLog(),"PathToTMVAWeighstFolder" , OneMLPPerTimeStep );
	IM_RK4* Solver = new IM_RK4( gCLASS->GetLog() );
	PhysicsModels* PHYMOD = new PhysicsModels( XS , Equivalence , Solver );
	
	...
	Reactor *PWR_MOX = new Reactor(log, PHYMOD, fabricationplant, Pool, creationtime, lifetime, cycletime, HMMass, BurnUp);
	...
}			
\end{lstlisting}
\end{minipage}
\end{center}

In this latter example a Physics model called "PHYMOD" is defined, it contains the bateman solver "Solver" which is the Runge Kutta ($4^{th}$ order) method. The mean cross sections predictor, "XS",  used is  based on a Multi Layer Perceptron. The Equivalence Model "Equivalence" is the one used for PWR MOX fuels. The arguments of the 3 objects constructor are explained in its corresponding sections.

All the existing models are define in the following sections, furthermore, the way to build its own Model is presented.




%%%%%%%%%%%%%%%%%%%%%%%%%
%%		EQUIVALENCE MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Equivalence Model}\label{sec:Equivalence}
The aim of an equivalence model is to predict the content of fissile element needed in a fuel to reach a given burn-up or to satisfied criticality conditions.
\section{Available Equivalence Models}
The CLASS package contains, for the moment, 4 different equivalence models where three are related to the building of fuels for a PWR-MOX and one to the building of  PWR-UOX fuels :
\subsection{PWR-MOX models :}
The following models returns the molar fraction $\%_{Pu}$ of plutonium needed to reach a given burn-up according to the plutonium isotopic composition available in stocks.



\subsubsection{Linear BU model : EQM\_LIN\_MOX } 
It was initially applied for MOX fuel, but because of the lack of precision, this model could be deprecated (at least in the PWR MOX case). It remain in the CLASS packages only because it was present historically.\\
 Nevertheless it could be use as an example for similar model for other fuel. This model suppose it is possible to describe the maximal burn-up accessible for a set fuel using its initial composition using a simple linear modelisation (equation~\ref{eq:EQM_LIN}):\\ 
\begin{equation}\label{eq:EQM_LIN}
BU_{max} = \alpha_{0} +   \sum_{i}^{N} \alpha_{i} \cdot n_{i},
\end{equation}
where $BU_{max}$ represent the maximal accessible burn-up for the fuel, $n_{i}$ the isotopic fraction of the isotope $i$, $N$ the number of isotope present in the fuel, and the $\alpha_{i}$ the parameter of the model. 
The main difficulty concerning this model, is the determination of the $\alpha_{i}$: to be correct the $\alpha_{i}$ should be fitted on a set of evolution data which are not constrain to reach an unique burn-up, but a large burn-up region. One can see the problem guessing it is possible to build a set a fuel evolution reaching exactly a unique burn-up (45 GWd/t by example), the $\chi^{2}$ minimization of the $\alpha_i$ will end up with $\alpha_{0} = 45$ and all the other at zero. That why, when using a linear burn-up description model, one should test the validity of the model, on many random compositions by example... 

\subsubsection{Quadratic Model : EQM\_QUAD\_MOX}
The $\%_{Pu}$ is calculated according a quadratic model. See equation~\ref{eq:EQM_QUAD_MOX}.
\begin{equation}\label{eq:EQM_QUAD_MOX}
\%_{Pu} = \alpha_{0} +   \sum_{i\in Pu}^{N} \left(\alpha_{i} \cdot n_{i}\ + \sum_{j\leq i} \alpha_{ij} \cdot n_{i}\cdot n_{j}\right),
\end{equation}
where $n_{i}$ is the molar proportion (in $\%mol.$) of isotope $i$ \footnote{from $^{238}Pu$ to $^{242}Pu$} in the fresh plutonium vector.  $\alpha_{ij}$, $\alpha_{i}$ and $\alpha_{0}$  are the weights resulting from a minimization procedure and are related to one targeted burn-up and one fuel management. Furthermore, $^{241}Am$ from $^{241}Pu$ decay is not one of the considered component of the model ($n_{i}$), instead the model considers a fixed time since plutonium separation. For instance the $\alpha$ given in file \$CLASS\_PATH/DataBase/Equivalence/PWR\_MOX\_45GW\_3Batch\_2y.dat
are representative of a PWR-MOX with a maximal burn-up of $45GWd/tHM$, a fuel management of 3 batches, and a time between separation and irradiation of 2 years.

The file containing the weights is formatted as follow :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
PARAM "238Pu 238Pu*238Pu 238Pu*239Pu 238Pu*240Pu 238Pu*241Pu 238Pu*242Pu 239Pu 239Pu*239Pu 239Pu*240Pu 239Pu*241Pu 239Pu*242Pu 240Pu 240Pu*240Pu 240Pu*241Pu 240Pu*242Pu 241Pu 241Pu*241Pu 241Pu*242Pu 242Pu 242Pu*242Pu 1"
\end{lstlisting}
\end{minipage}
\end{center}

Where 238Pu stands for $\alpha_{^{238}Pu}$ and it is the first order weight  related to the  molar proportion of $^{238}Pu$ and $1$ is $\alpha_{0}$. The weights are in units of $\%mol. \cdot \%mol.^{-1}$ for $\alpha_{i}$ in units of  $\%mol. \cdot \%mol.^{-2}$ for  $\alpha_{ij}$ and in units of $\%mol.$ for $\alpha_{0}$. The Keyword "PARAM" has to be present in the file before the $\alpha$ values. For more informations about this model and the generation of the coefficients please refer to reference [@@PAPIER BAM].
\\  
\\

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx }
\begin{lstlisting}[label=lst:IMP_EQMQUAD,caption=Equivalence Model EQM\_QUAD\_MOX ]
...
#include "Equivalence/EQM_QUAD_PWR_MOX.hxx"
...
int main()
{
...
EQM_QUAD_PWR_MOX* Equivalence = new	EQM_QUAD_PWR_MOX( LogObject, AlphasFile );
// or
// EQM_QUAD_PWR_MOX* Equivalence = new	EQM_QUAD_PWR_MOX( AlphasFile );
...
}
\end{lstlisting}
\end{minipage}
\end{center}

With LogObject a CLASSLogger object (see section~\ref{sec:logclass}) and AlphasFile a string which is the complete path to the file containing the weights (the $\alpha$ parameters)
\\
\\

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Available weight file (.dat) : }
\begin{itemize}
\item \textbf{@@@ BAM}
\item \textbf{@@@ BAM}
\item ...
\end{itemize}
\end{minipage}
\end{center}

\subsubsection{Neural network model : EQM\_MLP\_MOX}\label{sec:EQMMOX}
This equivalence model  is based on a Multi Layer Perceptron (MLP) and  predict the amount of plutonium needed to reach \textbf{any burn-up}. The MLP inputs are the isotopic compositions of the plutonium (\textbf{including $^{241}Am$}), the enrichment of depleted uranium, and the targeted burn-up. The output is the plutonium content needed to reach the burn-up. This method uses the neural networks of the root module TMVA (@@@  Ref TMVA). To executes this model, TMVA is run in CLASS and need a .xml file. This file contains the neural network architecture and the weights resulting from the training procedure.
\\
\\
\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx : }
\begin{lstlisting}[label=lst:IMP_EQMMLP,caption=Equivalence Model EQM\_MLP\_PWR\_MOX ]
...
#include "Equivalence/EQM_MLP_PWR_MOX.hxx"
...
int main()
{
...
EQM_MLP_PWR_MOX* Equivalence = new	EQM_MLP_PWR_MOX( LogObject, TMVAWeightPath );
// or
// EQM_MLP_PWR_MOX.* Equivalence = new	EQM_MLP_PWR_MOX( TMVAWeightPath );
...
\end{lstlisting}
\end{minipage}
\end{center}

With LogObject a CLASSLogger object (see section~\ref{sec:logclass}) and TMVAWeightPath a string containing the path to the .xml file. 


In order to make his own .xml file one need to have a training data containing the fresh fuel composition and the achievable burn-up of many examples. The fuel composition is characterized by the mean of :
\begin{itemize}
\item The plutonium composition (\emph{i.e :} \%mol. of $^{238}Pu$, $^{239}Pu$, $^{240}Pu$, $^{241}Pu$, $^{242}Pu$, and $^{241}Am$)
\item The plutonium content (\emph{i.e :}  $\frac{Pu}{Pu+U}$)
\item The $^{235}U$ content in the depleted uranium.
\end{itemize}

The file \$CLASS\_PATH/DataBases/Equivalence/EQM\_MLP\_PWR\_MOX\_3batch.xml has been generated from the file \$CLASS\_PATH/Utils/Equivalence/PWR\_MOX\_MLP/Train\_MLP.cxx 
To train a new MLP from your own training sample proceed as follow : 
\begin{center}
\begin{minipage}{\textwidth} 
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/Utils/Equivalence/PWR_MOX_MLP
g++ -o Train_MLP `root-config --cflags` Train_MLP.cxx `root-config --glibs` -lTMVA -I$ROOTSYS/tmva/test/
Train_MLP YourTrainingData.root
\end{lstlisting}
\end{minipage}
\end{center}


Where YourTrainingData.root is a root file containing a TTree filled with fuel compositions and corresponding burn-ups. The .xml file will be generated in a folder named weight. The results of the testing procedure of the MLP are in a file named TMVA\_MOX\_Equivalence.root but will be presented to you graphically as soon as the training and the testing procedure are finished.

To make your YourTrainingData.root file you have to fill a TTree with your data. To do so, create a .cxx file and copy past this :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
	TFile*   fOutFile = new TFile("YourTrainingData.root","RECREATE"); //create the .root file
	TTree*   fOutT = new TTree("Data", "Data");//create the TTree
/**********************INITIALISATIONNN********************/
//WARNING : keep the same variable names :
	double U5_enrichment  = 0;
	double Pu8 				 = 0;
	double Pu9 				 = 0;
	double Pu10 			 = 0;
	double Pu11				 = 0;
	double Pu12 	     = 0;
	double Am1 	    	 = 0;
	double BU 				 = 0;   //BU means Burn-Up
	double teneur 		  = 0;	//French for content (here Pu content)
/**********************BRANCHING**************************/
	fOutT->Branch(	"U5_enrichment"	,&U5_enrichment	,"U5_enrichment/D"	);
	fOutT->Branch(	"Pu8"			,&Pu8			,"Pu8/D"			);
	fOutT->Branch(	"Pu9"			,&Pu9			,"Pu9/D"			);
	fOutT->Branch(	"Pu10"		,&Pu10		,"Pu10/D"			);
	fOutT->Branch(	"Pu11"		,&Pu11		,"Pu11/D"			);
	fOutT->Branch(	"Pu12"		,&Pu12		,"Pu12/D"			);
	fOutT->Branch(	"Am1"			,&Am1			,"Am1/D"			);
	fOutT->Branch(	"BU"			,&BU			,"BU/D"				);
	fOutT->Branch(	"teneur"	,&teneur	,"teneur/D"			);
/**********************FILLING******************************/
//	int Nex=NumberOfDifferentExample;
	for(int ex=0;ex<Nex;ex++)
	{ /*******Fresh Fuel Composition***********/
		U5_enrichment 	=  fU5_enrichment[ex]; 
		Pu8  	  		=  fPu8[ex];
		Pu9  	  		=  fPu9[ex];
		Pu10 	  		=  fPu10[ex];
		Pu11 	  		=  fPu11[ex];
		Pu12 	  		=  fPu12[ex];
		Am1 	  		=  fAm1[ex];
		teneur 	  	=  fteneur[ex];
		/*****Corresponding maximal Burn-up*******/
		BU   	  		=  BurnUps[ex]; 
		/****Fill the tree with this fuel composition and this burnup****/
		fOutT->Fill();
	}
	fOutFile->Write();
	delete fOutT;
	fOutFile-> Close();
	delete fOutFile;
}
\end{lstlisting}
\end{minipage}
\end{center}

Then, build the arrays fU5\_enrichment, fPu8 ... with your data, compile and execute.
For more informations about this model please refer to [@@Papier BaL].
\\
\\
\textbf{Available weight file (.xml) : }

\begin{center}
\begin{minipage}{\textwidth}
\begin{itemize}
\item \textbf{\$CLASS\_PATH/DataBases/Equivalence/EQM\_MLP\_PWR\_MOX\_3batch.xml} : Generated with 5000 MURE evolutions with different fuel composition, using a full mirrored assembly calculation with JEFF3.1.1 cross section and fission yield data bases. Valid for mono-recycling of plutonium and a fuel management of 3 batches. More details about the generation of this .xml file can be found in reference[@@@BaL paper].
\end{itemize}
\end{minipage}
\end{center}

\subsection{PWR-UOX model :}

\subsubsection{Linear Model: EQM\_LIN\_UOX}
@@@BAM

\section{How to build an Equivalence Model}
The strength of CLASS is to allow the user to build his own Physics models, this section explains how to build a new equivalence model and to incorporate it into CLASS.

First you have to create the file EQM\_NAME.cxx and EQM\_NAME.hxx, where NAME is a name you choose. 
Then open with a text editor the .hxx and copy past the following replacing NAME by the name you want.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:HXX_EQM,caption=EQM\_NAME.hxx ]
#ifndef _EQM_NAME_HXX
#define _EQM_NAME_HXX
#include "EquivalenceModel.hxx"
using namespace std;
//---------------------------------------------------------//
/*!
 Define a EQM_NAME
  Explain briefly what is it.
  @author YourName
  @version 3.0
 */
//________________________________________________________________________
class EQM_NAME : public EquivalenceModel
{
	public :
	/*Constructor*/
	EQM_NAME(/*parameters*/ ); //!< Explain what is the parameters (if any) 

	/**This function IS the equivalence model **/	
	double GetFissileMolarFraction(IsotopicVector Fissil,IsotopicVector Fertil,double BurnUp); //!<Return the molar fraction of fissile element 

	private :
	/*Your private variables*/
};
#endif
\end{lstlisting} 
\end{minipage}
\end{center}

Open the .cxx file and copy past the following in it (replacing NAME by the same name you used in the .hxx).
 
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:CXX_EQM,caption=EQM\_NAME.cxx ]
#include "EquivalenceModel.hxx"
#include "EQM_NAME.hxx"
#include "CLASSLogger.hxx"
/*Whatever include you need*/
//________________________________________________________________________
//		EQM_NAME
//
//	Brief description
//________________________________________________________________________
//Constructor(s)
EQM_NAME::EQM_NAME(/*parameters*/)
{
//.... Do whatever you want with your parameters
/*
	Fill the two isotopic vectors fFissileList and fFertileList 
	see explanation in the manual
*/
	//Fertile
	ZAI U8(92,238,0);
	ZAI U5(92,235,0);
	double U5_enrich= 0.0025;
	fFertileList = U5*U5_enrich + U8*(1-U5_enrich);

	//Fissile
	ZAI Pu8(94,238,0);
	ZAI Pu9(94,239,0);
	//...
	fFissileList = Pu8*1+Pu9*1+ /*...*/;
}
//_______________________________________________________________________
double EQM_NAME::GetFissileMolarFraction(IsotopicVector Fissil,IsotopicVector Fertil,double BurnUp)
{
//Code your Equivalence Model : This function has to return the molar fraction	of fissile in the fuel needed to reach the BurnUp(GWd/tHM) according to the composition of the Fissil and Fertil vectors 
}
\end{lstlisting} 
\end{minipage}
\end{center}

In the constructor (EQM\_NAME::EQM\_NAME) you have to fill two isotopic vectors named \textbf{fFissileList} and \textbf{fFertileList}. Don't declare these isotopic vector in the .hxx, there are already declared in the file src/EquivalenceModel.hxx. fFissileList is used by the FabricationPlant to do the chemical separation of the fissile element from the other present in stock. For instance, for the plutonium, add the ZAI $^{238}Pu$, $^{239}Pu$, $^{240}Pu$, $^{241}Pu$ and $^{242}Pu$. fFertile List is used by the FabricationPlant the same way fFissileList is used but you have to define a default IsotopicVector to be used if you didn't provide a fertile stock to your FabricationPlant.  In the example given above the fertile is depleted uranium and  the proportion of each isotope is given ($^{234}U$ is unheeded). Now you have to build the function \textbf{GetFissileMolarFraction(IsotopicVector Fissil, IsotopicVector Fertil, double BurnUp)}. Its parameters are provided by the FabricationPlant and are :

\begin{itemize}
\item IsotopicVector Fissil : it is the proportion of each nucleus you give in the fFissileList plus the proportion of the nuclei that appears during the fabrication time (time given in the FabricationPlant constructor, is default is 2 years)
\item IsotopicVector Fertil :  it is the proportion of each nucleus you give in the fFertileList plus the proportion of the nuclei that appears during the fabrication time. If you didn't provide any fertile stock to your FabricationPlant then it's the default vector given in the EQM\_NAME constructor.
\item double BurnUp : The maximal average burn-up for your fuel to reach (in GWd/tHM).
\end{itemize}
Fill free to have a look at the models present in \$CLASS\_PATH/source/Model/Equivalence to get inspiration.

Now that your equivalence model is ready two choices are offered to you. You can compile the two files of your model with your CLASS input or you can add this model to the CLASS package. The second option will modify the CLASS software and we will be no longer able to troubleshoot your scenario. So use the second option only if you are a completely independent user !

\subsection{Compile your equivalence model with your CLASS executable :}
@@BAM

\subsection{Your equivalence model in the CLASS library :}
Move your  EQM\_NAME.hxx and  EQM\_NAME.cxx in \$CLASS\_PATH/source/Model/Equivalence/. Then open with your favourite text editor the file  \$CLASS\_PATH/source/src/Makefile, find "OBJMODEL" and add \$(EQM)/EQM\_NAME.o within the others \$(EQM) objects. Then re-compile CLASS, fix the compilation errors ;) and voilà your equivalence model is now available in the CLASS library.




%%%%%%%%%%%%%%%%%%%%%%%%%
%%		XS MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{XS Model}
The aim of a mean cross section model (XSModel) is to predict the mean cross sections of a fuel built by an EquivalenceModel (EQM) (see section \ref{sec:Equivalence}). The mean cross sections are required to compute fuel depletion in a reactor.

\section{Available XS Models}
There is, for the moment, 2 XSModel in CLASS : 
\subsection{Pre-calculated XS : XSM\_CLOSEST}\label{sec:CLOSEST}
This method looks, in a data base, for a fresh fuel with a composition \textbf{close} to the brandy new fuel built by the EquivalenceModel. Here, close means that the fresh fuel in the data base minimizes the distance $d$ (see equation~\ref{eq:distance}).
\begin{equation}\label{eq:distance}
d=\sqrt{\sum_{i} w_{i}\cdot(n_{i}^{DB} - n_{i}^{new} )^{2} },
\end{equation}
where $n_{i}^{DB}$ is the number of nuclei $i$ in one element of the data base and  $n_{i}^{new}$ the number of nuclei $i$ in the new fuel built by the EQM. $w_{i}$ is a weight associated to each isotopes, its value is 1 by default.
When the closest evolution in the database is found, the corresponding mean cross sections are extracted and used for the calculation of the depletion of the new fuel.
\\
\\
\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx : }
\begin{lstlisting}[label=lst:IMP_EQMQUAD,caption=Cross section Model XSM\_CLOSEST ]
...
#include "XS/XSM_CLOSEST.hxx"
...
int main()
{
	XSM_CLOSEST* XSMOX = new XSM_CLOSEST( gCLASS->GetLog(), PathToIdxFile );
	//or
	//XSM_CLOSEST* XSMOX = new XSM_CLOSEST( PathToIdxFile );
}
\end{lstlisting}
\end{minipage}
\end{center}

With LogObject a CLASSLogger object (see section~\ref{sec:logclass}) and PathToIdxFile  a string containing the path to the .idx file. The .idx file lists all the EvolutionData (see section~\ref{sec:EvolutionData}) of the data base. This file is formatted as follow :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
TYPE "NameOfTheFuel(withoutspace)"
"PATH_TO_DATA_BASE/EvolutionName.dat"
"PATH_TO_DATA_BASE/OtherEvolutionName.dat"
....
\end{lstlisting}
\end{minipage}
\end{center}

Each EvolutionName.dat file contains a fuel depletion calculation formatted as follow :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:DatFormat,caption=Evolution Data format]
time "0 t2 t3 ..."						// in seconds
keff "k1 k2 k3 ..."					// not mandatory entry
flux "phi1 phi2 phi3 ..." 			//(neutron/(second.cm2))not mandatory entry
Inv "Z A I inv1 inv2 inv 3 ..."		//in atoms
...
XSFis "Z A I xsfis1 xsfis2 xsfis3 ..."//in barns
... 
XSCap "Z A I xscap1 xscap2 xscap3 ..."
...
XSn2n "Z A I xsn2n1 xsnsn2 xsn2n3 ..."
...
\end{lstlisting}
\end{minipage}
\end{center}

The meaning of each keyword is listed in table~\ref{tab:meanKeyWord}. The number of .dat files has an influence on the model accuracy. Furthermore, the initial composition of the different fuel depletion calculations has to be representative of the fresh fuel compositions encounter in a scenario. For more details on this method please refer to [ref @@@ BAM physor]. 

\begin{table}[H]
\begin{center}
\caption{.dat Key words meaning}
\label{tab:meanKeyWord}
\begin{tabular}{|c|c|}
\hline
Key words & Meaning \\
\hline
Inv & Inventory \\
\hline
XSFis & mean fission cross section \\
XSCap & mean $(n,\gamma)$ cross section\\
XSn2n & mean $(n,2n)$ cross section \\
\hline
\hline
Value & meaning \\
\hline
Z & Charge number\\
A & Mass number\\
I & State (fundamental=0, $1^{st}$ excited =1, ...) \\
\hline
\end{tabular}
\end{center}

\end{table}

Each EvolutionName.dat files comes with a EvolutionName.info file, which describes the reactor, it is formatted like this :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
Reactor "ReactorName"		//What ever string without space
Fueltype "FuelName"			//What ever string without space
CycleTime "t"						//The final time simulated (@@BaM)
ConstantPower "P"				//Simulated power (in W)
\end{lstlisting}
\end{minipage}
\end{center}

\textbf{Available .idx file  : }
\begin{itemize}
\item \textbf{@@@ BAM}
\item \textbf{@@@ BAM}
\item ...
\end{itemize}

\textbf{For MURE user only : } The program \$CLASS\_PATH/Utils/XS/CLOSEST/WriteDataBase converts a list of MURE evolutions to a list of .dat and .info files and creates the .idx file, type in terminal the following command for more details.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
\$CLASS\_PATH/Utils/XS/CLOSEST/WriteDataBase -h 
@@BAM
\end{lstlisting}
\end{minipage}
\end{center}

Users of others fuel depletion code (\emph{e.g} VESTA, ORIGEN, MONTEBURNS, SERPENT .... ) have to create their own program to generate these files.




\subsection{XS predictor : XSM\_MLP}
This method calculates the mean cross sections by the mean of a set of neural networks (MLP from TMVA module) . There is two configurations available :

\begin{itemize}
\item One MLP per nuclear reaction and per time step (this one is deprecated and not describe in this manual) .
\item	One MLP per nuclear reaction. the irradiation time is one of the MLP inputs.
\end{itemize}

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx : }
\begin{lstlisting}[label=lst:IMP_EQMQUAD,caption=Cross section Model XSM\_MLP ]
...
#include "XS/XSM_MLP.hxx"
...
int main()
{	...
	XSM_MLP* XSMOX = new XSM_MLP( ClassLog, PathToWeightFolder, InfoFileName, OneMLPPerTime );
//or
//XSM_MLP* XSMOX = new XSM_MLP(PathToWeightFolder, InfoFileName, OneMLPPerTime);
...
}
\end{lstlisting}
\end{minipage}
\end{center}
\textbf{PathToWeightFolder} (string) is the path to the folder containing the weight files (.xml files). \textbf{OneMLPPerTime} is a boolean setted to true if there is one MLP per reaction and per time step. \textbf{InfoFileName} (string) is the name of the file located in PathToWeightFolder which is informing on the reactor and on the inputs of the XS\_MLP model.
Format of InfoFileName is :
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:informationfile,caption=Information file format]
ReactorType :"ReactorName"	//without space
FuelType :"FuelName" //without space
Heavy Metal (t) :"m"
Thermal Power (W) :"P"     //power corresponding to the heavy metal mass
Time (s) :"0 t2 t3 t4 ..." //Time when the cross section are updated
Z A I Name (input MLP) : //see explanations below
"z a i InputName"
"z2 a2 i2 InputName2"
"..."
\end{lstlisting}
\end{minipage}
\end{center}

The input of MLPs are the atomic proportion of each nuclei present in the fresh fuel (plus time if OneMLPPerTime=false). The InfoFile has to indicates the variable names (nuclei name) you used for the \textcolor{blue}{\textbf{training of your MLPs}}. For instance if the fresh fuel contains $^{238}Pu$ you will write in the InfoFile  :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
...
Z A I Name (input MLP) :
94 238 0 Pu8//(if Pu8 is the variable name used for 238Pu proportion in fresh fuel in your training sample) 
...
\end{lstlisting}
\end{minipage}
\end{center}

\textcolor{blue}{\large{\textbf{Training MLPs for cross sections prediction :}}}\\

\textbf{\underline{ Preparation of the training sample :} }\\
\\
Like for the equivalence model, first of all you have to create a training sample. This is one of the most important thing since the way of filling the hyperspace of the MLP inputs will influence the accuracy of your model. We suggest to used the Latin Hyper Cube method [@@@REFF] to generate many fresh fuel compositions, then, calculates with your favourite neutron transport code (MCNP, MORET, SERPENT ...) the mean cross sections of each fresh fuel for different irradiation time. Please refer to [REFFFBAL MLPXS] for more informations about the space filling and the validation of this cross sections predictor .
Once all your calculations are complete you have to convert them into the .dat format (see code frame~\ref{lst:DatFormat}).
Then type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/Utils/XS/MLP/BuildInput
\end{lstlisting}
\end{minipage}
\end{center}

Open the file Gene.cxx, looks for @@Change and make the appropriate changes. Then type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
g++ -o Gene Gene.cxx `root-config --cflags` `root-config --libs`
Gene PATH_To_dat_Folder/
\end{lstlisting}
\end{minipage}
\end{center}

Where  PATH\_To\_dat\_Folder/ is the path to the folder containing the .dat files. This program should have built two files :

\begin{itemize}
\item TrainingInput.root : This root file contains the fresh fuel inventories and the cross sections values of all the read .dat files. You can plot the data with the root command line tool if you wish. This file is the \textbf{Training and testing sample} that will be used for the TMVA training and testing procedure.
 
\item TrainingInput.cxx : This file contains, in a vector, the names of all the MLP outputs. The number of lines in this file is the number of MLP that will be train.
\end{itemize} 

\textbf{\underline{ Training and testing procedure : }}\\
\\
Once the two TrainingInput (.cxx and .root) are generated type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/Utils/XS/MLP/Train
\end{lstlisting}
\end{minipage} 
\end{center}

 Look for @@Change in the file Train\_XS.cxx , and make the appropriate changes. Then type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
 g++ -o Train_XS  `root-config --cflags` Train_XS.cxx `root-config --glibs` -lTMVA
\end{lstlisting}
\end{minipage} 
\end{center}

According the number of "events" in your .root file and the number of cross sections, the training time can be very very very long. You might want to decrease the number of events (this will probably deteriorate the model accuracy) : look for nTrain\_Regression in Train\_XS.cxx and change its value to your wanted number of events. And/Or you may want to use more than one processor or perhaps a supercomputer : This is completely doable since the program Train\_XS trains only one MLP (one cross section). Indeed the execution line is the following :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
Train_XS i
\end{lstlisting}
\end{minipage} 
\end{center}

where i is the index of the cross section in the vector created in TrainingInput.cxx. So feel free to create a script to run the training on a wanted number of processors. For instance let's say you have 40 cross sections and 4 processors, creates 4 files (make them executable) and in the first one type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
Train_XS 0
Train_XS 1
...
TrainXS 9
\end{lstlisting}
\end{minipage} 
\end{center}

continue in the second file, and so on. Then execute all of them. The architecture and weights of each MLP (.xml files) are stored in the folder weights. Rename this folder by the name of the reactor and fuel, then create in this folder the information file (see code frame~\ref{lst:informationfile}). And voilà your new XSM\_MLP is ready to be used.\\

After each training (using by default the half of the events) a testing procedure (using the other half) is performed. This latter consists on executing the trained MLP with input data from a known sample and compare the MLP result to the true value. These data and other informations about the training are stored in file \textbf{Training\_output\_i.root}, with i the index of the cross section. In order to see either the MLPs predictions are accurate or not, the root macro \$CLASS\_PATH/Utils/XS/MLP/Train/deviations.C plot the distribution of relative differences between model executions and the true values and a  Gaussian fit of it. Then, the mean and the standard deviation of the Gaussian fit are stored in file \textbf{XS\_accuracy.dat} (format : XSName mean std.dev.). Type the following to get, in file XS\_accuracy.dat, the mean and the standard deviation of all the MLPs (with N the number of cross sections (number of MLPs) ) :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS\_PATH/Utils/XS/MLP/Train/
root
.L deviations.C
for(int i=0;i<N;i++) {stringstream ss;ss<<"Training_output_"<<i<<".root";deviations(ss.str().c_str(),0,kTRUE,kFALSE,kFALSE); }
\end{lstlisting}
\end{minipage} 
\end{center}
 
 The closest to 0 the mean is and the smaller standard deviation, the better.
 
 

\section{How to build an XS Model}
The strength of CLASS is to allow the user to build his own Physics models, this section explains how to build a new cross section model and to incorporate it into CLASS.
First you have to create the file XSM\_NAME.cxx and XSM\_NAME.hxx, where NAME is a name you choose. 
Then open with a text editor the .hxx and copy past the following replacing NAME by the name you want.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:HXX_XSM,caption=XSM\_NAME.hxx ]
#ifndef _XSM_NAME_HXX
#define _XSM_NAME_HXX
#include "XSModel.hxx"
// add include if needed
using namespace std;
//----------------------------------------------------------------------//
/*!
 Define a XSM_NAME
describe your model
 @authors YourName
 @version 1.0
 */
//________________________________________________________________________
class XSM_NAME : public XSModel
{
	public :
	
	XSM_NAME(/*parameters (if any)*/);

	~XSM_NAME();

 	EvolutionData GetCrossSections(IsotopicVector IV,double t=0);

	private :			
	//your private variables and methods
};
#endif
\end{lstlisting}
\end{minipage} 
\end{center}


Open the .cxx file and copy past the following in it (replacing NAME by the same name you used in the .hxx).
 
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:CXX_XSM,caption=XSM\_NAME.cxx ]
#include "XSModel.hxx"
#include "XSM_NAME.hxx"
#include "CLASSLogger.hxx"
#include "StringLine.hxx"

#include <TGraph.h>
//________________________________________________________________________
//
//		XSM_NAME
//________________________________________________________________________
XSM_NAME::XSM_NAME(/*parameters (if any)*/)
{
// do what you want : for instance save path of eventual files
}
//________________________________________________________________________
XSM_NAME::~XSM_NAME()
{
 //delete pointer if any; clear map if any ; empty vector if any
}
//________________________________________________________________________
EvolutionData XSM_NAME::GetCrossSections(IsotopicVector IV ,double t)
{
	EvolutionData EvolutionDataFromXSM_NAME = EvolutionData();
	/*************DATA BASE INFO****************/
	EvolutionDataFromXSM_NAME.SetReactorType(fDataBaseRType);//Give the reactor name
	EvolutionDataFromXSM_NAME.SetFuelType(fDataBaseFType);//Give the fuel name
	EvolutionDataFromXSM_NAME.SetPower(fDataBasePower);//Set the power W
	EvolutionDataFromXSM_NAME.SetHeavyMetalMass(fDataBaseHMMass);//corresponding to this mass (t)
	
	map<ZAI,TGraph*> ExtrapolatedXS[3];
//... Fill the 3 maps ExtrapolatedXS  according to your model and the
// fresh fuel composition given by argument IsotopicVector IV 
// argument double t may be not used. 	

	/*****THE CROSS SECTIONS***/
	EvolutionDataFromXSM_NAME.SetFissionXS(ExtrapolatedXS[0]);
	EvolutionDataFromXSM_NAME.SetCaptureXS(ExtrapolatedXS[1]);
	EvolutionDataFromXSM_NAME.Setn2nXS(ExtrapolatedXS[2]);

return EvolutionDataFromXSM_NAME;
}
\end{lstlisting}
\end{minipage} 
\end{center}

Then, edit these two files to make the function XSM\_NAME::GetCrossSections to return the cross sections in a EvolutionData object. To do so you have to fill three maps (ExtrapolatedXS in .cxx), one for fission, one for $(n,\gamma)$, and one for $(n,2n)$ . Each map associates a nucleus (a ZAI) to a TGraph. A TGraph is a root object, here, it contains the cross section (barns) evolution over time (seconds). If your are not comfortable with TGraph refer to the  \href{http://root.cern.ch/root/html/TGraph.html}{root website}
\footnote{http://root.cern.ch/root/html/TGraph.html}

Now that your cross section model is ready, two choices are offered to you. You can compile the two files of your model with your CLASS input or you can add this model to the CLASS package. The second option will modify the CLASS software and we will be no longer able to troubleshoot your scenario. So use the second option only if you are a completely independent user !

\subsection{Compile your cross section model with your CLASS executable :}
@@BAM

\subsection{Your cross section model in the CLASS library :}
Move your  XSM\_NAME.hxx and  XSM\_NAME.cxx in \$CLASS\_PATH/source/Model/XS/. Then open with your favourite text editor the file \\ \$CLASS\_PATH/source/src/Makefile, find "OBJMODEL" and add \$(XSM)/XSM\_NAME.o within the others \$(XSM) objects. Then re-compile CLASS, fix the compilation errors ;) and voilà your cross section model is now available in the CLASS library.





%%%%%%%%%%%%%%%%%%%%%%%%%
%% IRRADIATION MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Irradiation Model}

\textbf{The irradiation model is the Bateman equations solver}. It is used for the calculation of fuel depletion in reactor. The decay depletion (without neutron flux) is not managed by an irradiation model but with a decay data bases (see section~\ref{sec:DecayDB}). 

\section{Available Irradiation Model}
At the moment, there is two Irradiation Model available. The two solvers differs according to the numerical integration method used. The Irradiation Model IM\_RK4 uses the fourth order Runge-Kutta method. And IM\_Matrix uses the development in a power series of the exponential of the Bateman matrix.

\begin{center}
\begin{minipage}{\textwidth}
\textbf{ Implementation in a .cxx :}
\begin{lstlisting}[label=lst:IMP_IRM,caption=Irradiation Model ]
#include "CLASSHeaders.hxx"
#include "Irradiation/IM_RK4.hxx"
//#include "Irradiation/IM_Matrix.hxx"
..
using namespace std;
int main()
{
//...
	IM_RK4* Solver = new IM_RK4(LogObject); // or new IM_RK4(); // uses a default logfile
//	IM_Matrix* Solver = new IM_Matrix(LogObject); // or new IM_Matrix(); //uses default logfile
	PhysicsModels* PHYMOD = new PhysicsModels(XSMOX, EQMLINPWRMOX, Solver);
//...	
}
\end{lstlisting}
\end{minipage} 
\end{center}
LogObject is a  CLASSLogger object (see section~\ref{sec:logclass}).

\subsection{How to build an Irradiation Model}
The strength of CLASS is to allow the user to build his own Physics models, this section explains how to build a new Bateman solver (Irradiation Model) and to incorporate it into CLASS.
First you have to create the file IRM\_NAME.cxx and IRM\_NAME.hxx, where NAME is a name you choose. 
Then open with a text editor the .hxx and copy past the following replacing NAME by the name you want.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:HXX_IRM,caption=lRM\_NAME.hxx ]
#ifndef _IRM_NAME_HXX
#define _IRM_NAME_HXX

#include "IrradiationModel.hxx"
using namespace std;
class CLASSLogger;
class EvolutionData;
//----------------------------------------------------------------------//
/*!
 Define a IM_NAME
Description
 @author YourName
 @version 3.0
 */
//________________________________________________________________________
class IM_NAME : public IrradiationModel
{
	public :
	IM_NAME(); //constructor

	/*!
	virtual method called to perform the irradiation calculation using a set of cross sections.
	 \param IsotopicVector IV isotopic vector to irradiate
	 \param EvolutionData XSSet set of corss section to use to perform the evolution calculation
	 */
	EvolutionData GenerateEvolutionData(IsotopicVector IV, EvolutionData XSSet, double Power, double cycletime);
	//}
	private :
	//declare your private variables here	
};
#endif
\end{lstlisting}
\end{minipage} 
\end{center}

Open the .cxx file and copy past the following in it (replacing NAME by the same name you used in the .hxx).
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:CXX_IRM,caption=lRM\_NAME.cxx ]
#include "IRM_NAME.hxx"
#include "CLASSLogger.hxx"
#include <TGraph.h>
//Add whatever includes
using namespace std;
//________________________________________________________________________
IRM_NAME::IRM_NAME():IrradiationModel(new CLASSLogger("IRM_NAME.log"))
{
	// do what you want
}
//________________________________________________________________________
EvolutionData IRM_NAME::GenerateEvolutionData(IsotopicVector FreshFuelIV, EvolutionData XSSet, double Power, double cycletime)
{
	EvolutionData GeneratedDB = EvolutionData(GetLog());
	GeneratedDB.SetPower(Power );
	GeneratedDB.SetReactorType(ReactorType );
	
//Your Solver algorithm has to  fill GeneratedDB with the calculated inventories
//using :
GeneratedDB.NucleiInsert(pair<ZAI, TGraph*> (ZAI(Z,A,I), new TGraph(SizeOfpTime, pTime, pZAIQuantity)));	
		
	return GeneratedDB;
}
\end{lstlisting}
\end{minipage} 
\end{center}
The function \textbf{GenerateEvolutionData} returns a \emph{EvolutionData} (see section~\ref{sec:EvolutionData}) containing the inventories evolution over time. This has to be done according to the fresh fuel composition (\textbf{FreshFuelIV}), to the mean cross sections (\textbf{XSSet}), to the (\textbf{Power} : thermal power (W)) and to the irradiation time (\textbf{cycletime} (seconds)).
To fill this  \emph{EvolutionData} you have to call the method  \textbf{NucleiInsert} which associates a nucleus (a ZAI) to  a root object \href{http://root.cern.ch/root/html/TGraph.html}{TGraph}
\footnote{http://root.cern.ch/root/html/TGraph.html}. This TGraph is the evolution (\textbf{pZAIQuantity} in atoms) of this associated nucleus  (\textbf{ZAI(Z,A,I)}) over time (\textbf{pTime} in seconds). This TGraph has \textbf{SizeOfpTime} points.

After making the appropriate changes in this two files to make the function \textbf{GenerateEvolutionData} to return the fuel evolution  (fill free to look at\\
 \$CLASS\_PATH/source/Model/Irradiation/*xx to get inspiration ),  two choices are offered to you. You can compile the two files of your model with your CLASS input or you can add this model to the CLASS package. The second option will modify the CLASS software and we will be no longer able to troubleshoot your scenario. So use the second option only if you are a completely independent user !


\subsection{Compile your cross section model with your CLASS executable :}
@@BAM

\subsection{Your cross section model in the CLASS library :}
Move your  IRM\_NAME.hxx and  IRM\_NAME.cxx in \$CLASS\_PATH/source/Model/Irradiation/. Then open with your favourite text editor the file \\ \$CLASS\_PATH/source/src/Makefile, find "OBJMODEL" and add \$(IM)/IRM\_NAME.o within the others \$(IM) objects. Then re-compile CLASS, fix the compilation errors ;) and voilà your irradiation model is now available in the CLASS library.




%%%%%%%%%%%%%%%%%%%%%%%%%
%% CHAPTER :	CLASSGUI
%%%%%%%%%%%%%%%%%%%%%%%%%
\part{CLASSGui : The results viewer}





%%%%%%%%%%%%%%%%%%%%%%%%%
%% CHAPTER :	INPUT EXAMPLE
%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Input examples}




%%%%%%%%%%%%%%%%%%%%%%%%%
%% CHAPTER :	IN DEVELOPMENT
%%%%%%%%%%%%%%%%%%%%%%%%%
\part{In development}



% === main matter ===
%\mainmatter
%\linenumbers
%\part{Recherche de la Vibration G\'eante de Paires}
%\include{ithemba_chapter_1_intro}
%\include{ithemba_chapter_2_des_exp}
%\include{ithemba_chapter_3_analyse}
%\include{ithemba_chapter_4_crosssection}
%\include{ithemba_chapter_5_discussion}
%\part{Mesure du temps de vie du premier état excité $2^{+}$ du $^{74}$Zn par m\'ethode plunger.}
\bibliographystyle{wmaainf}
\bibliography{Biblio}

\end{document}
