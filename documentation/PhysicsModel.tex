% !TEX root = USEGUIDE.tex

\part{Physics Models\label{sec:PhysicsModels}}
\chapter{Description and implementation}
A PhysicsModels is related to one or several reactors, it is a container of three models :
\begin{itemize}
\item Equivalence Model : Tells to the Fabrication Plant how to build the fuel.
\item XS Model : "Calculates" the mean  cross sections of this fuel and sends it to the Bateman Solver.
\item Irradiation Model : It is the Bateman Solver. User can choose between different numerical methods.
\end{itemize}

A PhysicsModels is called in the CLASS input like the following example :

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx :}
\begin{lstlisting}[label=lst:PIMP_HYMOD, caption=PhysicsModels]
...
#include "XS/XSM_MLP.hxx"
#include "Irradiation/IM_RK4.hxx"
#include "Equivalence/EQM_MLP_PWR_MOX.hxx"
int main()
{
	....

	EQM_MLP_MOX* Equivalence 	= new EQM_MLP_MOX( "PathToTMVAWeightFile/TMVAWeightFile.xml" );
	XSM_MLP* XS = new XSM_MLP( gCLASS->GetLog(),"PathToTMVAWeighstFolder" , OneMLPPerTimeStep );
	IM_RK4* Solver = new IM_RK4( gCLASS->GetLog() );
	PhysicsModels* PHYMOD = new PhysicsModels( XS , Equivalence , Solver );
	
	...
	Reactor *PWR_MOX = new Reactor(log, PHYMOD, fabricationplant, Pool, creationtime, lifetime, cycletime, HMMass, BurnUp);
	...
}			
\end{lstlisting}
\end{minipage}
\end{center}

In this latter example a PhysicsModels called "PHYMOD" is defined, it contains the bateman solver "Solver" which is the Runge Kutta ($4^{th}$ order) method. The mean cross sections predictor, "XS",  used is  based on a Multi Layer Perceptron. The Equivalence Model "Equivalence" is the one used for PWR MOX fuels. The arguments of the 3 objects constructor are explained in its corresponding sections.

All the existing models are defined in the following sections, furthermore, the way to build a new model is presented.




%%%%%%%%%%%%%%%%%%%%%%%%%
%%		EQUIVALENCE MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Equivalence Model}\label{sec:EquivalenceModel}
The aim of an equivalence model is to predict the content of fissile element needed in a fuel to reach a given burn-up or to satisfied criticality conditions.
\section{Available Equivalence Models}
The CLASS package contains, at the moment, 4 different equivalence models where three are related to the building of fuels for a PWR-MOX and one to the building of  PWR-UOX fuels :
\subsection{PWR-MOX models :}
The following models returns the molar fraction $\%_{Pu}$ of plutonium needed to reach a given burn-up according to the plutonium isotopic composition available in stocks.



\subsubsection{Linear BU model : EQM\_LIN\_MOX } 
It was initially applied for MOX fuel, but because of the lack of precision, this model could be deprecated (at least in the PWR MOX case). It remain in the CLASS packages only because it was present historically.\\
 Nevertheless it could be use as an example for similar model for other fuel. This model suppose it is possible to describe the maximal burn-up accessible for a set fuel using its initial composition using a simple linear modelisation (equation~\ref{eq:EQM_LIN}):\\ 
\begin{equation}\label{eq:EQM_LIN}
BU_{max} = \alpha_{0} +   \sum_{i}^{N} \alpha_{i} \cdot n_{i},
\end{equation}
where $BU_{max}$ represent the maximal accessible burn-up for the fuel, $n_{i}$ the isotopic fraction of the isotope $i$, $N$ the number of isotope present in the fuel, and the $\alpha_{i}$ the parameter of the model. 
The main difficulty concerning this model, is the determination of the $\alpha_{i}$: to be correct the $\alpha_{i}$ should be fitted on a set of evolution data which are not constrain to reach an unique burn-up, but a large burn-up region. One can see the problem guessing it is possible to build a set a fuel evolution reaching exactly a unique burn-up (45 GWd/t by example), the $\chi^{2}$ minimization of the $\alpha_i$ will end up with $\alpha_{0} = 45$ and all the other at zero. That why, when using a linear burn-up description model, one should test the validity of the model, on many random compositions by example... 

\subsubsection{Quadratic Model : EQM\_QUAD\_MOX}
The $\%_{Pu}$ is calculated according a quadratic model. See equation~\ref{eq:EQM_QUAD_MOX}.
\begin{equation}\label{eq:EQM_QUAD_MOX}
\%_{Pu} = \alpha_{0} +   \sum_{i\in Pu}^{N} \left(\alpha_{i} \cdot n_{i}\ + \sum_{j\leq i} \alpha_{ij} \cdot n_{i}\cdot n_{j}\right),
\end{equation}
where $n_{i}$ is the molar proportion (in $\%mol.$) of isotope $i$ \footnote{from $^{238}Pu$ to $^{242}Pu$} in the fresh plutonium vector.  $\alpha_{ij}$, $\alpha_{i}$ and $\alpha_{0}$  are the weights resulting from a minimization procedure and are related to one targeted burn-up and one fuel management. Furthermore, $^{241}Am$ from $^{241}Pu$ decay is not one of the considered component of the model ($n_{i}$), instead the model considers a fixed time since plutonium separation. For instance the $\alpha$ given in file \$CLASS\_PATH/DATA\_BASES/PWR/MOX/EQModel/@@BAM
are representative of a PWR-MOX with a maximal burn-up of $45GWd/tHM$, a fuel management of 3 batches, and a time between separation and irradiation of 2 years.

The file containing the weights is formatted as follow :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
PARAM "238Pu 238Pu*238Pu 238Pu*239Pu 238Pu*240Pu 238Pu*241Pu 238Pu*242Pu 239Pu 239Pu*239Pu 239Pu*240Pu 239Pu*241Pu 239Pu*242Pu 240Pu 240Pu*240Pu 240Pu*241Pu 240Pu*242Pu 241Pu 241Pu*241Pu 241Pu*242Pu 242Pu 242Pu*242Pu 1"
\end{lstlisting}
\end{minipage}
\end{center}

Where 238Pu stands for $\alpha_{^{238}Pu}$ and it is the first order weight  related to the  molar proportion of $^{238}Pu$ and $1$ is $\alpha_{0}$. The weights are in units of $\%mol. \cdot \%mol.^{-1}$ for $\alpha_{i}$ in units of  $\%mol. \cdot \%mol.^{-2}$ for  $\alpha_{ij}$ and in units of $\%mol.$ for $\alpha_{0}$. The Keyword "PARAM" has to be present in the file before the $\alpha$ values. For more informations about this model and the generation of the coefficients please refer to reference [@@PAPIER BAM].
\\  
\\

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx }
\begin{lstlisting}[label=lst:IMP_EQMQUAD,caption=Equivalence Model EQM\_QUAD\_MOX ]
...
#include "Equivalence/EQM_QUAD_PWR_MOX.hxx"
...
int main()
{
...
EQM_QUAD_PWR_MOX* Equivalence = new	EQM_QUAD_PWR_MOX( LogObject, AlphasFile );
// or
// EQM_QUAD_PWR_MOX* Equivalence = new	EQM_QUAD_PWR_MOX( AlphasFile );
...
}
\end{lstlisting}
\end{minipage}
\end{center}

With LogObject a \hyperref[sec:CLASSLogger]{CLASSLogger} object (see section~\ref{sec:CLASSLogger}) and AlphasFile a string which is the complete path to the file containing the weights (the $\alpha$ parameters)
\\
\\

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Available weight file (.dat) : }
\begin{itemize}
\item \textbf{@@@ BAM}
\item \textbf{@@@ BAM}
\item ...
\end{itemize}
\end{minipage}
\end{center}

\subsubsection{Neural network model : EQM\_MLP\_MOX}\label{sec:EQMMOX}
This equivalence model  is based on a Multi Layer Perceptron (MLP) and  predict the amount of plutonium needed to reach \textbf{any burn-up}. The MLP inputs are the isotopic compositions of the plutonium (\textbf{including $^{241}Am$}), the enrichment of depleted uranium, and the targeted burn-up. The output is the plutonium content needed to reach the burn-up. This method uses the neural networks of the root module TMVA (@@@  Ref TMVA). To executes this model, TMVA is run in CLASS and need a .xml file. This file contains the neural network architecture and the weights resulting from the training procedure.
\\
\\
\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx : }
\begin{lstlisting}[label=lst:IMP_EQMMLP,caption=Equivalence Model EQM\_MLP\_PWR\_MOX ]
...
#include "Equivalence/EQM_MLP_PWR_MOX.hxx"
...
int main()
{
...
EQM_MLP_PWR_MOX* Equivalence = new	EQM_MLP_PWR_MOX( LogObject, TMVAWeightPath );
// or
// EQM_MLP_PWR_MOX.* Equivalence = new	EQM_MLP_PWR_MOX( TMVAWeightPath );
...
\end{lstlisting}
\end{minipage}
\end{center}

With LogObject a \hyperref[sec:CLASSLogger]{CLASSLogger} object (see section~\ref{sec:CLASSLogger}) and TMVAWeightPath a string containing the path to the .xml file. 


In order to make his own .xml file one need to have a training data containing the fresh fuel composition and the achievable burn-up of many examples. The fuel composition is characterized by the mean of :
\begin{itemize}
\item The plutonium composition (\emph{i.e :} \%mol. of $^{238}Pu$, $^{239}Pu$, $^{240}Pu$, $^{241}Pu$, $^{242}Pu$, and $^{241}Am$)
\item The plutonium content (\emph{i.e :}  $\frac{Pu}{Pu+U}$)
\item The $^{235}U$ content in the depleted uranium.
\end{itemize}

The file \$CLASS\_PATH/DATA\_BASES/PWR/MOX/EQModel/EQM\_MLP\_PWR\_MOX\_3batch.xml has been generated from the file \$CLASS\_PATH/Utils/EQM/PWR\_MOX\_MLP/Train\_MLP.cxx 
To train a new MLP from your own training sample proceed as follow : 
\begin{center}
\begin{minipage}{\textwidth} 
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/Utils/EQM/PWR_MOX_MLP
g++ -o Train_MLP `root-config --cflags` Train_MLP.cxx `root-config --glibs` -lTMVA -I$ROOTSYS/tmva/test/
Train_MLP YourTrainingData.root
\end{lstlisting}
\end{minipage}
\end{center}


Where YourTrainingData.root is a root file containing a TTree filled with fuel compositions and corresponding burn-ups. The .xml file will be generated in a folder named weight. The results of the testing procedure of the MLP are in a file named TMVA\_MOX\_Equivalence.root but will be presented to you graphically as soon as the training and the testing procedure are finished.

To make your YourTrainingData.root file you have to fill a TTree with your data. To do so, create a .cxx file and copy past this :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
	TFile*   fOutFile = new TFile("YourTrainingData.root","RECREATE"); //create the .root file
	TTree*   fOutT = new TTree("Data", "Data");//create the TTree
/**********************INITIALISATIONNN********************/
//WARNING : keep the same variable names :
	double U5_enrichment  = 0;
	double Pu8 				 = 0;
	double Pu9 				 = 0;
	double Pu10 			 = 0;
	double Pu11				 = 0;
	double Pu12 	     = 0;
	double Am1 	    	 = 0;
	double BU 				 = 0;   //BU means Burn-Up
	double teneur 		  = 0;	//French for content (here Pu content)
/**********************BRANCHING**************************/
	fOutT->Branch(	"U5_enrichment"	,&U5_enrichment	,"U5_enrichment/D"	);
	fOutT->Branch(	"Pu8"			,&Pu8			,"Pu8/D"			);
	fOutT->Branch(	"Pu9"			,&Pu9			,"Pu9/D"			);
	fOutT->Branch(	"Pu10"		,&Pu10		,"Pu10/D"			);
	fOutT->Branch(	"Pu11"		,&Pu11		,"Pu11/D"			);
	fOutT->Branch(	"Pu12"		,&Pu12		,"Pu12/D"			);
	fOutT->Branch(	"Am1"			,&Am1			,"Am1/D"			);
	fOutT->Branch(	"BU"			,&BU			,"BU/D"				);
	fOutT->Branch(	"teneur"	,&teneur	,"teneur/D"			);
/**********************FILLING******************************/
//	int Nex=NumberOfDifferentExample;
	for(int ex=0;ex<Nex;ex++)
	{ /*******Fresh Fuel Composition***********/
		U5_enrichment 	=  fU5_enrichment[ex]; 
		Pu8  	  		=  fPu8[ex];
		Pu9  	  		=  fPu9[ex];
		Pu10 	  		=  fPu10[ex];
		Pu11 	  		=  fPu11[ex];
		Pu12 	  		=  fPu12[ex];
		Am1 	  		=  fAm1[ex];
		teneur 	  	=  fteneur[ex];
		/*****Corresponding maximal Burn-up*******/
		BU   	  		=  BurnUps[ex]; 
		/****Fill the tree with this fuel composition and this burnup****/
		fOutT->Fill();
	}
	fOutFile->Write();
	delete fOutT;
	fOutFile-> Close();
	delete fOutFile;
}
\end{lstlisting}
\end{minipage}
\end{center}

Then, build the arrays fU5\_enrichment, fPu8 ... with your data, compile and execute.
For more informations about this model please refer to [@@Papier BaL].\\
\textbf{Available weight file (.xml) : }
\begin{itemize}
\item \textbf{\$CLASS\_PATH/DATA\_BASES/PWR/MOX/EQModel/EQM\_MLP\_PWR\_MOX\_3batch.xml} : Generated with 5000 MURE evolutions with different fuel composition, using a full mirrored assembly calculation with JEFF3.1.1 cross section and fission yield data bases. Valid for mono-recycling of plutonium and a fuel management of 3 batches. More details about the generation of this .xml file can be found in reference[@@@BaL paper].
\end{itemize}


\subsection{PWR-UOX model :}

\subsubsection{Linear Model: EQM\_LIN\_UOX}
@@@BAM

\section{How to build an Equivalence Model}
The strength of CLASS is to allow the user to build his own Physics models, this section explains how to build a new equivalence model and to incorporate it into CLASS.

First you have to create the file EQM\_NAME.cxx and EQM\_NAME.hxx, where NAME is a name you choose. 
Then open with a text editor the .hxx and copy past the following replacing NAME by the name you want.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:HXX_EQM,caption=EQM\_NAME.hxx ]
#ifndef _EQM_NAME_HXX
#define _EQM_NAME_HXX
#include "EquivalenceModel.hxx"
using namespace std;
//---------------------------------------------------------//
/*!
 Define a EQM_NAME
  Explain briefly what is it.
  @author YourName
  @version 3.0
 */
//________________________________________________________________________
class EQM_NAME : public EquivalenceModel
{
	public :
	/*Constructor*/
	EQM_NAME(/*parameters*/ ); //!< Explain what is the parameters (if any) 

	/**This function IS the equivalence model **/	
	double GetFissileMolarFraction(IsotopicVector Fissil,IsotopicVector Fertil,double BurnUp); //!<Return the molar fraction of fissile element 

	private :
	/*Your private variables*/
};
#endif
\end{lstlisting} 
\end{minipage}
\end{center}

Open the .cxx file and copy past the following in it (replacing NAME by the same name you used in the .hxx).
 
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:CXX_EQM,caption=EQM\_NAME.cxx ]
#include "EquivalenceModel.hxx"
#include "EQM_NAME.hxx"
#include "CLASSLogger.hxx"
/*Whatever include you need*/
//________________________________________________________________________
//		EQM_NAME
//
//	Brief description
//________________________________________________________________________
//Constructor(s)
EQM_NAME::EQM_NAME(/*parameters*/)
{
//.... Do whatever you want with your parameters
/*
	Fill the two isotopic vectors fFissileList and fFertileList 
	see explanation in the manual
*/
	//Fertile
	ZAI U8(92,238,0);
	ZAI U5(92,235,0);
	double U5_enrich= 0.0025;
	fFertileList = U5*U5_enrich + U8*(1-U5_enrich);

	//Fissile
	ZAI Pu8(94,238,0);
	ZAI Pu9(94,239,0);
	//...
	fFissileList = Pu8*1+Pu9*1+ /*...*/;
}
//_______________________________________________________________________
double EQM_NAME::GetFissileMolarFraction(IsotopicVector Fissil,IsotopicVector Fertil,double BurnUp)
{
//Code your Equivalence Model : This function has to return the molar fraction	of fissile in the fuel needed to reach the BurnUp(GWd/tHM) according to the composition of the Fissil and Fertil vectors 
}
\end{lstlisting} 
\end{minipage}
\end{center}

In the constructor (EQM\_NAME::EQM\_NAME) you have to fill two isotopic vectors named \textbf{fFissileList} and \textbf{fFertileList}. Don't declare these isotopic vector in the .hxx, there are already declared in the file src/EquivalenceModel.hxx. fFissileList is used by the FabricationPlant to do the chemical separation of the fissile element from the other present in stock. For instance, for the plutonium, add the ZAI $^{238}Pu$, $^{239}Pu$, $^{240}Pu$, $^{241}Pu$ and $^{242}Pu$. fFertile List is used by the FabricationPlant the same way fFissileList is used but you have to define a default \hyperref[sec:IsotopicVector]{IsotopicVector} to be used if you didn't provide a fertile stock to your FabricationPlant.  In the example given above the fertile is depleted uranium and  the proportion of each isotope is given ($^{234}U$ is unheeded). Now you have to build the function \textbf{GetFissileMolarFraction(IsotopicVector Fissil, IsotopicVector Fertil, double BurnUp)}. Its parameters are provided by the FabricationPlant and are :

\begin{itemize}
\item \hyperref[sec:IsotopicVector]{IsotopicVector} Fissile : it is the proportion of each nucleus you give in the fFissileList plus the proportion of the nuclei that appears during the fabrication time (time given in the FabricationPlant constructor, is default is 2 years)
\item \hyperref[sec:IsotopicVector]{IsotopicVector} Fertile :  it is the proportion of each nucleus you give in the fFertileList plus the proportion of the nuclei that appears during the fabrication time. If you didn't provide any fertile stock to your FabricationPlant then it's the default vector given in the EQM\_NAME constructor.
\item double BurnUp : The maximal average burn-up for your fuel to reach (in GWd/tHM).
\end{itemize}
Fill free to have a look at the models present in \$CLASS\_PATH/source/Model/Equivalence to get inspiration.

Now that your equivalence model is ready two choices are offered to you. You can compile the two files of your model with your CLASS input or you can add this model to the CLASS package. The second option will modify the CLASS software and we will be no longer able to troubleshoot your scenario. So use the second option only if you are a completely independent user !

\subsection{Compile your equivalence model with your CLASS executable :}
@@BAM

\subsection{Your equivalence model in the CLASS library :}
Move your  EQM\_NAME.hxx and  EQM\_NAME.cxx in \$CLASS\_PATH/source/Model/Equivalence/. Then open with your favourite text editor the file  \$CLASS\_PATH/source/src/Makefile, find "OBJMODEL" and add \$(EQM)/EQM\_NAME.o within the others \$(EQM) objects. Then re-compile CLASS, fix the compilation errors ;) and voilà your equivalence model is now available in the CLASS library.




%%%%%%%%%%%%%%%%%%%%%%%%%
%%		XS MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{XS Model}
The aim of a mean cross section model (XSModel) is to predict the mean cross sections of a fuel built by an EquivalenceModel (EQM) (see section \ref{sec:EquivalenceModel}). The mean cross sections are required to compute fuel depletion in a reactor.

\section{Available XS Models}
There is, for the moment, 2 XSModel in CLASS : 
\subsection{Pre-calculated XS : XSM\_CLOSEST}\label{sec:CLOSEST}
This method looks, in a data base, for a fresh fuel with a composition \textbf{close} to the brandy new fuel built by the EquivalenceModel. Here, close means that the fresh fuel in the data base minimizes the distance $d$ (see equation~\ref{eq:distance}).
\begin{equation}\label{eq:distance}
d=\sqrt{\sum_{i} w_{i}\cdot(n_{i}^{DB} - n_{i}^{new} )^{2} },
\end{equation}
where $n_{i}^{DB}$ is the number of nuclei $i$ in one element of the data base and  $n_{i}^{new}$ the number of nuclei $i$ in the new fuel built by the EQM. $w_{i}$ is a weight associated to each isotopes, its value is 1 by default.
When the closest evolution in the database is found, the corresponding mean cross sections are extracted and used for the calculation of the depletion of the new fuel.
\\
\\
\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx : }
\begin{lstlisting}[label=lst:IMP_EQMQUAD,caption=Cross section Model XSM\_CLOSEST ]
...
#include "XS/XSM_CLOSEST.hxx"
...
int main()
{
	XSM_CLOSEST* XSMOX = new XSM_CLOSEST( gCLASS->GetLog(), PathToIdxFile );
	//or
	//XSM_CLOSEST* XSMOX = new XSM_CLOSEST( PathToIdxFile );
}
\end{lstlisting}
\end{minipage}
\end{center}

With LogObject a \hyperref[sec:CLASSLogger]{CLASSLogger} object (see section~\ref{sec:CLASSLogger}) and PathToIdxFile  a string containing the path to the .idx file. The .idx file lists all the EvolutionData (see section~\ref{sec:EvolutionData}) of the data base. This file is formatted as follow :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
TYPE "NameOfTheFuel(withoutspace)"
"PATH_TO_DATA_BASE/EvolutionName.dat"
"PATH_TO_DATA_BASE/OtherEvolutionName.dat"
....
\end{lstlisting}
\end{minipage}
\end{center}

Each EvolutionName.dat file contains a formatted fuel depletion calculation. the format of a EvolutionData ASCII file is detailed in section~\ref{sec:EDformat}.  The number of .dat files has an influence on the model accuracy. Furthermore, the initial composition of the different fuel depletion calculations has to be representative of the fresh fuel compositions encounter in a scenario. For more details on this method please refer to [ref @@@ BAM physor]. 


\textbf{Available .idx file  : }
\begin{itemize}
\item \textbf{@@@ BAM}
\item \textbf{@@@ BAM}
\item ...
\end{itemize}

\textbf{For MURE user only : } The program \$CLASS\_PATH/Utils/MURE2CLASS converts a list of MURE evolutions to a list of .dat and .info files and creates the .idx file, type in terminal the following command for more details.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
\$CLASS\_PATH/Utils/MURE2CLASS -h 
@@BAM
\end{lstlisting}
\end{minipage}
\end{center}

Users of others fuel depletion code (\emph{e.g} VESTA, ORIGEN, MONTEBURNS, SERPENT .... ) have to create their own program to generate these files.




\subsection{XS predictor : XSM\_MLP}
This method calculates the mean cross sections by the mean of a set of neural networks (MLP from TMVA module) . There is two configurations available :

\begin{itemize}
\item One MLP per nuclear reaction and per time step (this one is deprecated and not describe in this manual) .
\item	One MLP per nuclear reaction. the irradiation time is one of the MLP inputs.
\end{itemize}

\begin{center}
\begin{minipage}{\textwidth}
\textbf{Implementation in a .cxx : }
\begin{lstlisting}[label=lst:IMP_EQMQUAD,caption=Cross section Model XSM\_MLP ]
...
#include "XS/XSM_MLP.hxx"
...
int main()
{	...
	XSM_MLP* XSMOX = new XSM_MLP( ClassLog, PathToWeightFolder, InfoFileName, OneMLPPerTime );
//or
//XSM_MLP* XSMOX = new XSM_MLP(PathToWeightFolder, InfoFileName, OneMLPPerTime);
...
}
\end{lstlisting}
\end{minipage}
\end{center}
\textbf{PathToWeightFolder} (string) is the path to the folder containing the weight files (.xml files). \textbf{OneMLPPerTime} is a boolean setted to true if there is one MLP per reaction and per time step. \textbf{InfoFileName} (string) is the name of the file located in PathToWeightFolder which is informing on the reactor and on the inputs of the XS\_MLP model.
Format of InfoFileName is :
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:informationfile,caption=Information file format]
ReactorType :"ReactorName"	//without space
FuelType :"FuelName" //without space
Heavy Metal (t) :"m"
Thermal Power (W) :"P"     //power corresponding to the heavy metal mass
Time (s) :"0 t2 t3 t4 ..." //Time when the cross section are updated
Z A I Name (input MLP) : //see explanations below
"z a i InputName"
"z2 a2 i2 InputName2"
"..."
\end{lstlisting}
\end{minipage}
\end{center}

The input of MLPs are the atomic proportion of each nuclei present in the fresh fuel (plus time if OneMLPPerTime=false). The InfoFile has to indicates the variable names (nuclei name) you used for the \textcolor{blue}{\textbf{training of your MLPs}}. For instance if the fresh fuel contains $^{238}Pu$ you will write in the InfoFile  :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
...
Z A I Name (input MLP) :
94 238 0 Pu8//(if Pu8 is the variable name used for 238Pu proportion in fresh fuel in your training sample) 
...
\end{lstlisting}
\end{minipage}
\end{center}
\textbf{Available XSM\_MLP : }
\begin{itemize}
\item \$CLASS\_PATH/DATA\_BASES/PWR/MOX/XSModel/30Wg\_FullMOX :
The weight files and .nfo file contained in this folder are representative of a PWR MOX. With the MOX coming from PWR UO2 spent fuels. The specific power is 30W/g oxide. To perform this data base, MURE depletion calculations have been performed using a full MOX assembly with mirror boundaries. 
\end{itemize}

\textcolor{blue}{\large{\textbf{Training MLPs for cross sections prediction :}}}\\

\textbf{\underline{ Preparation of the training sample :} }\\
\\
Like for the equivalence model, first of all you have to create a training sample. This is one of the most important thing since the way of filling the hyperspace of the MLP inputs will influence the accuracy of your model. We suggest to used the Latin Hyper Cube method [@@@REFF] to generate many fresh fuel compositions, then, calculates with your favourite neutron transport code (MCNP, MORET, SERPENT ...) the mean cross sections of each fresh fuel for different irradiation time. Please refer to [REFFFBAL MLPXS] for more informations about the space filling and the validation of this cross sections predictor.
Once all your calculations are complete you have to convert them into the .dat format (see code frame~\ref{lst:DatFormat}).
Then type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/Utils/XS/MLP/BuildInput
\end{lstlisting}
\end{minipage}
\end{center}

Open the file Gene.cxx, looks for @@Change and make the appropriate changes. Then type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
g++ -o Gene Gene.cxx `root-config --cflags` `root-config --libs`
Gene PATH_To_dat_Folder/
\end{lstlisting}
\end{minipage}
\end{center}

Where  PATH\_To\_dat\_Folder/ is the path to the folder containing the .dat files. This program should have built two files :

\begin{itemize}
\item TrainingInput.root : This root file contains the fresh fuel inventories and the cross sections values of all the read .dat files. You can plot the data with the root command line tool if you wish. This file is the \textbf{Training and testing sample} that will be used for the TMVA training and testing procedure.
 
\item TrainingInput.cxx : This file contains, in a vector, the names of all the MLP outputs. The number of lines in this file is the number of MLP that will be train.
\end{itemize} 

\textbf{\underline{ Training and testing procedure : }}\\
\\
Once the two TrainingInput (.cxx and .root) are generated type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS_PATH/Utils/XS/MLP/Train
\end{lstlisting}
\end{minipage} 
\end{center}

 Look for @@Change in the file Train\_XS.cxx , and make the appropriate changes. Then type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
 g++ -o Train_XS  `root-config --cflags` Train_XS.cxx `root-config --glibs` -lTMVA
\end{lstlisting}
\end{minipage} 
\end{center}

According the number of "events" in your .root file and the number of cross sections, the training time can be very very very long. You might want to decrease the number of events (this will probably deteriorate the model accuracy) : look for nTrain\_Regression in Train\_XS.cxx and change its value to your wanted number of events. And/Or you may want to use more than one processor or perhaps a supercomputer : This is completely doable since the program Train\_XS trains only one MLP (one cross section). Indeed the execution line is the following :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
Train_XS i
\end{lstlisting}
\end{minipage} 
\end{center}

where i is the index of the cross section in the vector created in TrainingInput.cxx. So feel free to create a script to run the training on a wanted number of processors. For instance let's say you have 40 cross sections and 4 processors, creates 4 files (make them executable) and in the first one type :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}
Train_XS 0
Train_XS 1
...
TrainXS 9
\end{lstlisting}
\end{minipage} 
\end{center}

continue in the second file, and so on. Then execute all of them. The architecture and weights of each MLP (.xml files) are stored in the folder weights. Rename this folder by the name of the reactor and fuel, then create in this folder the information file (see code frame~\ref{lst:informationfile}). And voilà your new XSM\_MLP is ready to be used.\\

After each training (using by default the half of the events) a testing procedure (using the other half) is performed. This latter consists on executing the trained MLP with input data from a known sample and compare the MLP result to the true value. These data and other informations about the training are stored in file \textbf{Training\_output\_i.root}, with i the index of the cross section. In order to see either the MLPs predictions are accurate or not, the root macro \$CLASS\_PATH/Utils/XS/MLP/Train/deviations.C plot the distribution of relative differences between model executions and the true values and a  Gaussian fit of it. Then, the mean and the standard deviation of the Gaussian fit are stored in file \textbf{XS\_accuracy.dat} (format : XSName mean std.dev.). Type the following to get, in file XS\_accuracy.dat, the mean and the standard deviation of all the MLPs (with N the number of cross sections (number of MLPs) ) :

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=terminal]
cd $CLASS\_PATH/Utils/XS/MLP/Train/
root
.L deviations.C
for(int i=0;i<N;i++) {stringstream ss;ss<<"Training_output_"<<i<<".root";deviations(ss.str().c_str(),0,kTRUE,kFALSE,kFALSE); }
\end{lstlisting}
\end{minipage} 
\end{center}
 
 The closest to 0 the mean is and the smaller standard deviation, the better.
 
 

\section{How to build an XS Model}
The strength of CLASS is to allow the user to build his own Physics models, this section explains how to build a new cross section model and to incorporate it into CLASS.
First you have to create the file XSM\_NAME.cxx and XSM\_NAME.hxx, where NAME is a name you choose. 
Then open with a text editor the .hxx and copy past the following replacing NAME by the name you want.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:HXX_XSM,caption=XSM\_NAME.hxx ]
#ifndef _XSM_NAME_HXX
#define _XSM_NAME_HXX
#include "XSModel.hxx"
// add include if needed
using namespace std;
//----------------------------------------------------------------------//
/*!
 Define a XSM_NAME
describe your model
 @authors YourName
 @version 1.0
 */
//________________________________________________________________________
class XSM_NAME : public XSModel
{
	public :
	
	XSM_NAME(/*parameters (if any)*/);

	~XSM_NAME();

 	EvolutionData GetCrossSections(IsotopicVector IV,double t=0);

	private :			
	//your private variables and methods
};
#endif
\end{lstlisting}
\end{minipage} 
\end{center}


Open the .cxx file and copy past the following in it (replacing NAME by the same name you used in the .hxx).
 
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:CXX_XSM,caption=XSM\_NAME.cxx ]
#include "XSModel.hxx"
#include "XSM_NAME.hxx"
#include "CLASSLogger.hxx"
#include "StringLine.hxx"

#include <TGraph.h>
//________________________________________________________________________
//
//		XSM_NAME
//________________________________________________________________________
XSM_NAME::XSM_NAME(/*parameters (if any)*/)
{
// do what you want : for instance save path of eventual files
}
//________________________________________________________________________
XSM_NAME::~XSM_NAME()
{
 //delete pointer if any; clear map if any ; empty vector if any
}
//________________________________________________________________________
EvolutionData XSM_NAME::GetCrossSections(IsotopicVector IV ,double t)
{
	EvolutionData EvolutionDataFromXSM_NAME = EvolutionData();
	/*************DATA BASE INFO****************/
	EvolutionDataFromXSM_NAME.SetReactorType(fDataBaseRType);//Give the reactor name
	EvolutionDataFromXSM_NAME.SetFuelType(fDataBaseFType);//Give the fuel name
	EvolutionDataFromXSM_NAME.SetPower(fDataBasePower);//Set the power W
	EvolutionDataFromXSM_NAME.SetHeavyMetalMass(fDataBaseHMMass);//corresponding to this mass (t)
	
	map<ZAI,TGraph*> ExtrapolatedXS[3];
//... Fill the 3 maps ExtrapolatedXS  according to your model and the
// fresh fuel composition given by argument IsotopicVector IV 
// argument double t may be not used. 	

	/*****THE CROSS SECTIONS***/
	EvolutionDataFromXSM_NAME.SetFissionXS(ExtrapolatedXS[0]);
	EvolutionDataFromXSM_NAME.SetCaptureXS(ExtrapolatedXS[1]);
	EvolutionDataFromXSM_NAME.Setn2nXS(ExtrapolatedXS[2]);

return EvolutionDataFromXSM_NAME;
}
\end{lstlisting}
\end{minipage} 
\end{center}

Then, edit these two files to make the function XSM\_NAME::GetCrossSections to return the cross sections in a EvolutionData object. (\textit{In this case, the EvolutionData only contains the 1 group cross section without the inventory evolution, the power and the corresponding mass.})\\
 To do so you have to fill three maps (ExtrapolatedXS in .cxx), one for fission, one for $(n,\gamma)$, and one for $(n,2n)$ . Each map associates a nucleus (a ZAI) to a TGraph. A TGraph is a root object, here, it contains the cross section (barns) evolution over time (seconds). If your are not comfortable with TGraph refer to the  \href{http://root.cern.ch/root/html/TGraph.html}{root website}
\footnote{http://root.cern.ch/root/html/TGraph.html}

Now that your cross section model is ready, two choices are offered to you. You can compile the two files of your model with your CLASS input or you can add this model to the CLASS package. The second option will modify the CLASS software and we will be no longer able to troubleshoot your scenario. So use the second option only if you are a completely independent user !

\subsection{Compile your cross section model with your CLASS executable :}
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:Compile]
g++ -g -O -I $CLASS_include -L $CLASS_lib -lCLASSpkg `root-config --cflags` 
	`root-config --libs` -fopenmp -lgomp -Wunused-result -c My_XS-MODEL.cxx
\end{lstlisting}
\end{minipage} 
\end{center}

\subsection{Your cross section model in the CLASS library :}
Move your  XSM\_NAME.hxx and  XSM\_NAME.cxx in \$CLASS\_PATH/source/Model/XS/. Then open with your favourite text editor the file \\ \$CLASS\_PATH/source/src/Makefile, find "OBJMODEL" and add \$(XSM)/XSM\_NAME.o within the others \$(XSM) objects. Then re-compile CLASS, fix the compilation errors ;) and voilà your cross section model is now available in the CLASS library.





%%%%%%%%%%%%%%%%%%%%%%%%%
%% IRRADIATION MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Irradiation Model}

\textbf{The irradiation model is the Bateman equations solver}. It is used for the calculation of fuel depletion in reactor. The decay depletion (without neutron flux) is not managed by an irradiation model but with a decay data bases (see section~\ref{sec:DecayDB}). 

\section{Available Irradiation Model}
At the moment, there is two Irradiation Model available. The two solvers differs according to the numerical integration method used. The Irradiation Model IM\_RK4 uses the fourth order Runge-Kutta method. And IM\_Matrix uses the development in a power series of the exponential of the Bateman matrix.

\begin{center}
\begin{minipage}{\textwidth}
\textbf{ Implementation in a .cxx :}
\begin{lstlisting}[label=lst:IMP_IRM,caption=Irradiation Model ]
#include "CLASSHeaders.hxx"
#include "Irradiation/IM_RK4.hxx"
//#include "Irradiation/IM_Matrix.hxx"
..
using namespace std;
int main()
{
//...
	IM_RK4* Solver = new IM_RK4(LogObject); // or new IM_RK4(); // uses a default logfile
//	IM_Matrix* Solver = new IM_Matrix(LogObject); // or new IM_Matrix(); //uses default logfile
	PhysicsModels* PHYMOD = new PhysicsModels(XSMOX, EQMLINPWRMOX, Solver);
//...	
}
\end{lstlisting}
\end{minipage} 
\end{center}
LogObject is a  \hyperref[sec:CLASSLogger]{CLASSLogger} object (see section~\ref{sec:CLASSLogger}).

\subsection{How to build an Irradiation Model}
The strength of CLASS is to allow the user to build his own Physics models, this section explains how to build a new Bateman solver (Irradiation Model) and to incorporate it into CLASS.
First you have to create the file IRM\_NAME.cxx and IRM\_NAME.hxx, where NAME is a name you choose. 
Then open with a text editor the .hxx and copy past the following replacing NAME by the name you want.

\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:HXX_IRM,caption=lRM\_NAME.hxx ]
#ifndef _IRM_NAME_HXX
#define _IRM_NAME_HXX

#include "IrradiationModel.hxx"
using namespace std;
class CLASSLogger;
class EvolutionData;
//----------------------------------------------------------------------//
/*!
 Define a IM_NAME
Description
 @author YourName
 @version 3.0
 */
//________________________________________________________________________
class IM_NAME : public IrradiationModel
{
	public :
	IM_NAME(); //constructor

	/*!
	virtual method called to perform the irradiation calculation using a set of cross sections.
	 \param IsotopicVector IV isotopic vector to irradiate
	 \param EvolutionData XSSet set of corss section to use to perform the evolution calculation
	 */
	EvolutionData GenerateEvolutionData(IsotopicVector IV, EvolutionData XSSet, double Power, double cycletime);
	//}
	private :
	//declare your private variables here	
};
#endif
\end{lstlisting}
\end{minipage} 
\end{center}

Open the .cxx file and copy past the following in it (replacing NAME by the same name you used in the .hxx).
\begin{center}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label=lst:CXX_IRM,caption=lRM\_NAME.cxx ]
#include "IRM_NAME.hxx"
#include "CLASSLogger.hxx"
#include <TGraph.h>
//Add whatever includes
using namespace std;
//________________________________________________________________________
IRM_NAME::IRM_NAME():IrradiationModel(new CLASSLogger("IRM_NAME.log"))
{
	// do what you want
}
//________________________________________________________________________
EvolutionData IRM_NAME::GenerateEvolutionData(IsotopicVector FreshFuelIV, EvolutionData XSSet, double Power, double cycletime)
{
	EvolutionData GeneratedDB = EvolutionData(GetLog());
	GeneratedDB.SetPower(Power );
	GeneratedDB.SetReactorType(ReactorType );
	
//Your Solver algorithm has to  fill GeneratedDB with the calculated inventories
//using :
GeneratedDB.NucleiInsert(pair<ZAI, TGraph*> (ZAI(Z,A,I), new TGraph(SizeOfpTime, pTime, pZAIQuantity)));	
		
	return GeneratedDB;
}
\end{lstlisting}
\end{minipage} 
\end{center}
The function \textbf{GenerateEvolutionData} returns a \emph{EvolutionData} (see section~\ref{sec:EvolutionData}) containing the inventories evolution over time. This has to be done according to the fresh fuel composition (\textbf{FreshFuelIV}), to the mean cross sections (\textbf{XSSet}), to the (\textbf{Power} : thermal power (W)) and to the irradiation time (\textbf{cycletime} (seconds)).
To fill this  \emph{EvolutionData} you have to call the method  \textbf{NucleiInsert} which associates a nucleus (a ZAI) to  a root object \href{http://root.cern.ch/root/html/TGraph.html}{TGraph}
\footnote{http://root.cern.ch/root/html/TGraph.html}. This TGraph is the evolution (\textbf{pZAIQuantity} in atoms) of this associated nucleus  (\textbf{ZAI(Z,A,I)}) over time (\textbf{pTime} in seconds). This TGraph has \textbf{SizeOfpTime} points.

After making the appropriate changes in this two files to make the function \textbf{GenerateEvolutionData} to return the fuel evolution  (fill free to look at\\
 \$CLASS\_PATH/source/Model/Irradiation/*xx to get inspiration ),  two choices are offered to you. You can compile the two files of your model with your CLASS input or you can add this model to the CLASS package. The second option will modify the CLASS software and we will be no longer able to troubleshoot your scenario. So use the second option only if you are a completely independent user !


\subsection{Compile your Irradiation model with your CLASS executable :}
@@BAM

\subsection{Your Irradiation model in the CLASS library :}
Move your  IRM\_NAME.hxx and  IRM\_NAME.cxx in \$CLASS\_PATH/source/Model/Irradiation/. Then open with your favourite text editor the file \\ \$CLASS\_PATH/source/src/Makefile, find "OBJMODEL" and add \$(IM)/IRM\_NAME.o within the others \$(IM) objects. Then re-compile CLASS, fix the compilation errors ;) and voilà your irradiation model is now available in the CLASS library.


